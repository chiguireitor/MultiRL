<!DOCTYPE html>
<html>
<head>
<title>Ganymede Gate</title>
<!--link rel="stylesheet" href="/templates/style.css"-->
<style>
.itchio {
    display: block;
    margin: 10px auto;
}

.onlyorigin {
    display: none;
}

.mail-list {
    text-align: center;
    width: 30%;
    margin: 0 auto;
    padding: 15px;
    display: block;
    color: #FFF;
    background-color: #444;
    border-radius: 5px 5px;
    text-decoration: none;
    font-family: calibri, tahoma, helvetica, sans;
}

.fsm {
    color: #0C0;
    border: 1px solid #4A4;
    background-color: #222;
    width: 200px;
    float: left;
}
</style>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="viewport" content="width=device-width, initial-scale=0.6, maximum-scale=0.6, user-scalable=0"/>
</script>
</head>
<body style="background: #000; overflow: hidden">

<div class="ascii" style="width: 100; text-align: center">
<div id="term" style="display: inline; cursor: none">
</div>
</div>
<a class="twitter-share-button onlyorigin"
  href="https://twitter.com/share?url=http://ganymedegate.com&via=johnvillarz&text=Played Ganymede Gate a pre-alpha multiplayer roguelike in development, come join me!&hashtags=roguelike">
Tweet
</a>

<div id="players" style="display: none">
<p><b>Players</b></p>
<div id="player_list">
</div>
</div>

<div style="width: 100%" id="announce">
</div>

<a href="http://eepurl.com/bysGjP" target="_blank" class="mail-list onlyorigin" style="display: none">Click to subscribe to Ganymede Gate's mailing list</a>

<iframe src="//itch.io/embed/36939?dark=true&amp;linkback=true" class="itchio onlyorigin" width="552" height="167" frameborder="0"></iframe>

<a href="https://github.com/chiguireitor/MultiRL" class="onlyorigin"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
<a href="https://gitter.im/chiguireitor/MultiRL" class="onlyorigin">Chat on gitter</a>

<script id="default-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform vec2 fontSize;
    uniform sampler2D uFont, uGlyphs, uForeground, uBackground, uLuma;
    uniform float damageRadius;
    uniform float uWidthDistort;
    uniform float uConsoleCharWidth;
    uniform int uUseLuma;

    void main(void) {
        //float x = gl_FragCoord.x / fontSize.x / 96.0 /* Console char width*/ * uWidthDistort;
        float x = gl_FragCoord.x / fontSize.x / uConsoleCharWidth * uWidthDistort;
        float y = gl_FragCoord.y / 512.0;
        
        float cx = fract(gl_FragCoord.x / fontSize.x) / 16.0;
        float cy = fract(gl_FragCoord.y / fontSize.y) / 16.0;
        
        vec4 glyph = texture2D(uGlyphs, vec2(x, y));
        
        // That green and red channel mingling? Yeah that's because some
        // mobile devices have less than 8 bits per channel
        float gp = floor(glyph.r * 256.0 + floor((glyph.g * 16.0) * 256.0)) / 16.0;
        float gy = 0.9375 - (floor(gp) / 16.0);
        float gx = gp - floor(gp);
        
        vec4 fnt = texture2D(uFont, vec2(gx + cx, gy + cy));
        vec4 fg = texture2D(uForeground, vec2(x, y));
        vec4 bg = texture2D(uBackground, vec2(x, y));
        
        gl_FragColor = mix(fg, bg, fnt.a); // Without scanlines
        //gl_FragColor = mix(fg, bg, fnt.a) * (min(mod(gl_FragCoord.y, 3.0), 2.0)/4.0 + 0.5); // With scanlines
        
        // These "if"s are for the damage radius around the screen edge
        float v = damageRadius;
        float cw = fontSize.x * uConsoleCharWidth;
        if (gl_FragCoord.x <= v){
            float d = (v - gl_FragCoord.x) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        //} else if ((gl_FragCoord.x >= (512.0 - v)) && (gl_FragCoord.x <= 512.0)) {
        } else if ((gl_FragCoord.x >= (cw - v)) && (gl_FragCoord.x <= cw)) {
            float d = (v - (cw - gl_FragCoord.x)) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        }
        
        if ((gl_FragCoord.y <= v) && (gl_FragCoord.x <= cw)) {
            float d = (v - gl_FragCoord.y) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        } else if ((gl_FragCoord.y >= (512.0 - v)) && (gl_FragCoord.x <= cw)) {
            float d = (v - (512.0 - gl_FragCoord.y)) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        }
        
        if (uUseLuma == 1) {
            vec4 luma = texture2D(uLuma, vec2(x, y));
            
            gl_FragColor = vec4(gl_FragColor.r * luma.r, gl_FragColor.g * luma.g, gl_FragColor.b * luma.b, gl_FragColor.a);
        }
    }
</script>

<script id="rtt-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        vec4 tx = texture2D(uTexture, vec2(x, y));
        
        gl_FragColor = tx;
    }
</script>

<script id="rtt-bloomx-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    const float td = 0.005;
    
    // 5x5 Gaussian blur matrix coefficients
    const float base = 149.0;
    const float mt1 = 1.0 / base;
    const float mt4 = 4.0 / base;
    const float mt7 = 7.0 / base;
    const float mt16 = 16.0 / base;
    const float mt26 = 26.0 / base;
    const float mt41 = 41.0 / base;
    
    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        float tdx1 = 1.0 / uViewportWidth;
        float tdy1 = 1.0 / uViewportHeight;
        float tdx2 = tdx1 * 2.0;
        float tdy2 = tdy1 * 2.0;
        float tdx3 = tdx1 * 3.0;
        float tdx4 = tdx1 * 4.0;
        float tdx5 = tdx1 * 5.0;
        
        vec4 tx02 = texture2D(uTexture, vec2(x-tdx5, y)) * mt1;
        vec4 tx12 = texture2D(uTexture, vec2(x-tdx4, y)) * mt4;
        vec4 tx22 = texture2D(uTexture, vec2(x-tdx3, y)) * mt7;
        vec4 tx32 = texture2D(uTexture, vec2(x-tdx2, y)) * mt16;
        vec4 tx42 = texture2D(uTexture, vec2(x-tdx1, y)) * mt26;
        vec4 tx52 = texture2D(uTexture, vec2(x, y)) * mt41;
        vec4 tx62 = texture2D(uTexture, vec2(x+tdx1, y)) * mt26;
        vec4 tx72 = texture2D(uTexture, vec2(x+tdx2, y)) * mt16;
        vec4 tx82 = texture2D(uTexture, vec2(x+tdx3, y)) * mt7;
        vec4 tx92 = texture2D(uTexture, vec2(x+tdx4, y)) * mt4;
        vec4 txA2 = texture2D(uTexture, vec2(x+tdx5, y)) * mt1;
        
        
        gl_FragColor = tx02 + tx12 + tx22 + tx32 + tx42 + tx52 + tx62 + tx72 + tx82 + tx92 + txA2;
    }
</script>

<script id="rtt-bloomy-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    const float td = 0.005;
    
    // 5x5 Gaussian blur matrix coefficients
    const float base = 143.0;
    const float mt1 = 1.0 / base;
    const float mt4 = 4.0 / base;
    const float mt7 = 7.0 / base;
    const float mt16 = 16.0 / base;
    const float mt26 = 26.0 / base;
    const float mt41 = 41.0 / base;
    
    const float gamma = 0.8;
    
    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        float tdy1 = 1.0 / uViewportHeight;
        float tdy2 = tdy1 * 2.0;
        float tdy3 = tdy1 * 3.0;
        float tdy4 = tdy1 * 4.0;
        float tdy5 = tdy1 * 5.0;
        
        vec4 tx02 = texture2D(uTexture, vec2(x, y-tdy5)) * mt1;
        vec4 tx12 = texture2D(uTexture, vec2(x, y-tdy4)) * mt4;
        vec4 tx22 = texture2D(uTexture, vec2(x, y-tdy3)) * mt7;
        vec4 tx32 = texture2D(uTexture, vec2(x, y-tdy2)) * mt16;
        vec4 tx42 = texture2D(uTexture, vec2(x, y-tdy1)) * mt26;
        vec4 tx52 = texture2D(uTexture, vec2(x, y)) * mt41;
        vec4 tx62 = texture2D(uTexture, vec2(x, y+tdy1)) * mt26;
        vec4 tx72 = texture2D(uTexture, vec2(x, y+tdy2)) * mt16;
        vec4 tx82 = texture2D(uTexture, vec2(x, y+tdy3)) * mt7;
        vec4 tx92 = texture2D(uTexture, vec2(x, y+tdy4)) * mt4;
        vec4 txA2 = texture2D(uTexture, vec2(x, y+tdy5)) * mt1;
        
        
        gl_FragColor = tx02 + tx12 + tx22 + tx32 + tx42 + tx52 + tx62 + tx72 + tx82 + tx92 + txA2;
        
        gl_FragColor = vec4(pow(gl_FragColor.rgb, vec3(1.0 / gamma)), gl_FragColor.a);
    }
</script>

<script id="rtt-semipix-fs" type="x-shader/x-fragment">
    // Lousy pseudo pixellated look
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        vec4 tx = texture2D(uTexture, vec2(x, y));
        
        gl_FragColor = tx * 0.8;
        
        if ((mod(floor(gl_FragCoord.x), 2.0) == 1.0) || (mod(floor(gl_FragCoord.y), 2.0) == 1.0)) {
            float gamma = 1.3;
            gl_FragColor = vec4(pow(gl_FragColor.rgb, vec3(1.0 / gamma)), gl_FragColor.a);
        }
    }
</script>

<script id="rtt-2xsai-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;
    
// Adapted form https://github.com/libretro/common-shaders/blob/master/xsai/super-2xsai.cg
    const vec3 dtt = vec3(65536,255,1);
    
    /*  GET_RESULT function                            */
    /*  Copyright (c) 1999-2001 by Derek Liauw Kie Fa  */
    /*  License: GNU-GPL                               */
    int GET_RESULT(float A, float B, float C, float D)
    {
        int x = 0;
        int y = 0;
        int r = 0;
        
        if (A == C) {
            x+=1;
        } else if (B == C) {
            y+=1;
        }
        
        if (A == D) {
            x+=1; 
        } else if (B == D) {
            y+=1;
        }
        
        if (x <= 1) {
            r+=1; 
        }
        if (y <= 1) {
            r-=1;
        }
        
        return r;
    } 


    float reduce(vec3 color)
    { 
        return dot(color, dtt);
    }


    void main(void)
    {
        vec2 texCoord = vec2(gl_FragCoord.x / uViewportWidth * uWidthDistort, gl_FragCoord.y / uViewportHeight);
        
        // get texel size   	
        vec2 ps = vec2(0.999/ 8.0 /* font width */ / 96.0 /* console char width */ * uWidthDistort, 0.999/512.0);
        
        // calculating offsets, coordinates

        vec2 dx = vec2( ps.x, 0.0); 
        vec2 dy = vec2( 0.0, ps.y);
        vec2 g1 = vec2( ps.x,ps.y);
        vec2 g2 = vec2(-ps.x,ps.y);	
        
        vec2 pixcoord  = texCoord/ps;
        vec2 fp        = fract(pixcoord);
        vec2 pC4       = texCoord-fp*ps;
        vec2 pC8       = pC4+g1;

        

        // Reading the texels

        vec3 C0 = texture2D(uTexture,pC4-g1).xyz; 
        vec3 C1 = texture2D(uTexture,pC4-dy).xyz;
        vec3 C2 = texture2D(uTexture,pC4-g2).xyz;
        vec3 D3 = texture2D(uTexture,pC4-g2+dx).xyz;
        vec3 C3 = texture2D(uTexture,pC4-dx).xyz;
        vec3 C4 = texture2D(uTexture,pC4   ).xyz;
        vec3 C5 = texture2D(uTexture,pC4+dx).xyz;
        vec3 D4 = texture2D(uTexture,pC8-g2).xyz;
        vec3 C6 = texture2D(uTexture,pC4+g2).xyz;
        vec3 C7 = texture2D(uTexture,pC4+dy).xyz;
        vec3 C8 = texture2D(uTexture,pC4+g1).xyz;
        vec3 D5 = texture2D(uTexture,pC8+dx).xyz;
        vec3 D0 = texture2D(uTexture,pC4+g2+dy).xyz;
        vec3 D1 = texture2D(uTexture,pC8+g2).xyz;
        vec3 D2 = texture2D(uTexture,pC8+dy).xyz;
        vec3 D6 = texture2D(uTexture,pC8+g1).xyz;

        vec3 p00,p10,p01,p11;


        // reducing float3 to float
        
        float c0 = reduce(C0);float c1 = reduce(C1);
        float c2 = reduce(C2);float c3 = reduce(C3);
        float c4 = reduce(C4);float c5 = reduce(C5);
        float c6 = reduce(C6);float c7 = reduce(C7);
        float c8 = reduce(C8);float d0 = reduce(D0);
        float d1 = reduce(D1);float d2 = reduce(D2);
        float d3 = reduce(D3);float d4 = reduce(D4);
        float d5 = reduce(D5);float d6 = reduce(D6);




        /*              Super2xSaI code               */
        /*  Copied from the Dosbox source code        */
        /*  Copyright (C) 2002-2007  The DOSBox Team  */
        /*  License: GNU-GPL                          */
        /*  Adapted by guest(r) on 19.4.2007          */

         
        if (c7 == c5 && c4 != c8) {
            p11 = p01 = C7;
        } else if (c4 == c8 && c7 != c5) {
            p11 = p01 = C4;
        } else if (c4 == c8 && c7 == c5) {
            int r = 0;
            r += GET_RESULT(c5,c4,c6,d1);
            r += GET_RESULT(c5,c4,c3,c1);
            r += GET_RESULT(c5,c4,d2,d5);
            r += GET_RESULT(c5,c4,c2,d4);

            if (r > 0)
                p11 = p01 = C5;
            else if (r < 0)
                p11 = p01 = C4;
            else {
                p11 = p01 = 0.5*(C4+C5);
            }
        } else {
            if (c5 == c8 && c8 == d1 && c7 != d2 && c8 != d0)
                p11 = 0.25*(3.0*C8+C7);
            else if (c4 == c7 && c7 == d2 && d1 != c8 && c7 != d6)
                p11 = 0.25*(3.0*C7+C8);
            else
                p11 = 0.5*(C7+C8);

            if (c5 == c8 && c5 == c1 && c4 != c2 && c5 != c0)
                p01 = 0.25*(3.0*C5+C4);
            else if (c4 == c7 && c4 == c2 && c1 != c5 && c4 != d3)
                p01 = 0.25*(3.0*C4+C5);
            else
                p01 = 0.5*(C4+C5);
        }

        if (c4 == c8 && c7 != c5 && c3 == c4 && c4 != d2)
            p10 = 0.5*(C7+C4);
        else if (c4 == c6 && c5 == c4 && c3 != c7 && c4 != d0)
            p10 = 0.5*(C7+C4);
        else
            p10 = C7;

        if (c7 == c5 && c4 != c8 && c6 == c7 && c7 != c2)
            p00 = 0.5*(C7+C4);
        else if (c3 == c7 && c8 == c7 && c6 != c4 && c7 != c0)
            p00 = 0.5*(C7+C4);
        else
            p00 = C4;


        // Distributing the four products
        
        if (fp.x < 0.50)
            { if (fp.y < 0.50) p10 = p00;}
        else
            { if (fp.y < 0.50) p10 = p01; else p10 = p11;}


        // OUTPUT
        gl_FragColor = vec4(p10, 1);
    }
    ////// End of super 2xsai
</script>

<script id="default-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<div id="shaders-edit" style="position: fixed; right: 0px; bottom: 0px; width: 500px; height: 100%; background: #444; color: #fff; display: none;">
<h2>Shaders!</h2>
<h3>Fragment</h3>
<textarea id="fs-edit" rows="15" cols="60" wrap="off" style="background: #000; font-family: monospace; color #ddd;" onfocus="disableGameInput()" onblur="enableGameInput()"></textarea><br>
<h3>Vertex</h3>
<textarea id="vs-edit" rows="15" cols="60" wrap="off" style="background: #000; font-family: monospace; color #ddd;" onfocus="disableGameInput()" onblur="enableGameInput()"></textarea><br>
<button onclick="updateShaders()">Update</button>
</div>

<script src="./templates/jquery-2.1.1.min.js"></script>
<script src="./templates/ASCIITerminal.js"></script>
<script src="./templates/ascii_mapping.js"></script>
<script src="./templates/traceline.js"></script>
<script src="./templates/pako_inflate.min.js"></script>
<script src="./templates/gl-matrix.js"></script>
<script src="./templates/soundjs-0.6.2.min.js"></script>
<script src="./templates/RexSprite.js"></script>
<script>
var player = {
    isAlive: false
}
var canCheat = false
var colorMap = {
    "lava": {"color": "FF8800", "cycle": "882200", "backgroundColor": [64, 0, 0], "msscale": 4000, "luma": [5120, 5120, 5120]},
    "plasma": {"color": "FF00FF", "cycle": "880088", "backgroundColor": [64, 0, 64], "msscale": 1000, "luma": [5120, 5120, 5120]},
    "wood": {"color": "A37936"},
    "dirt": {"color": "936926"},
    "acid": {"color": "008800", "cycle": "44FF00", "msscale": 1500, "backgroundColor": [0, 64, 0], "luma": [2550, 2550, 2550]},
    "water": {"color": "0044FF", "cycle": "002288", "msscale": 2000},
    "smoke": {"color": "888888", "cycle": "444444", "msscale": 1000},
    "debris": {"color": "888888", "cycle": "444444", "msscale": 500},
    "fire": {"color": "FF0000", "cycle": "CC8800", "msscale": 200, "luma": [255, 255, 255]},
    "particle-ammo-9mm-bullets": {"color": "FF0000"},
    "particle-ammo-9mm": {"color": "FF0000"},
    "particle-ammo-12ga": {"color": "FF0000"},
    "particle-ammo-Gasoline-tank": {"color": "FF4400", "cycle": "882200", "msscale": 500},
    "blood": {"color": "FF0000", "cycle": "440000", "msscale": 2000},
    "low-level-item": {"color": "999999"},
    "low-level-ammo": {"color": "999999"},
    "mid-level-item": {"color": "CC9999"},
    "mid-level-ammo": {"color": "CC9999"},
    "high-level-ammo": {"color": "CCCC77"},
    "heal": {"color": "E00000"},
    "heal-big": {"color": "FF4494"},
    "good-weapon": {"color": "FFEB69", "cycle": "DEC628", "msscale": 1000},
    "standard-weapon": {"color": "28DE9E", "cycle": "15BD82", "msscale": 1000},
    "dangerous-weapon": {"color": "D86000", "cycle": "804000", "msscale": 1000},
    "player-shadow": {"color": "0000AA", "cycle": "000044", "msscale": 1000},
    "sound-radio": {"color": "00FF88", "cycle": "0088FF", "msscale": 1000},
    
    "health-powerup": {"color": "FF6688"},
    "armor-powerup": {"color": "FFFF66"},
    "strength-powerup": {"color": "44FF22"},
    "precision-powerup": {"color": "4444FF"},
    "speed-powerup": {"color": "68AFFF"},
    "speed-powerup-plus": {"color": "28FFFF"},
    "heal-powerup": {"color": "CC0067"},
    "heal-powerup-plus": {"color": "EC0087"},
}

var sndVolume = 0.1
var bgm

function OpenInNewTab(url) {
  var win = window.open(url, '_blank')
  win.focus()
}

// Following two functions are from http://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

function hsvModulate(col, hm, sm, vm) {
    if (typeof(col) !== "undefined") {
        var hsv = RGBtoHSV(col[0], col[1], col[2])
        hsv.h *= hm
        hsv.s *= sm
        hsv.v *= vm
        
        var rgb = HSVtoRGB(hsv)
        
        return [rgb.r, rgb.g, rgb.b]
    }
}

function hsvModulateFlt(col, hm, sm, vm) {
    if (typeof(col) !== "undefined") {
        var hsv = RGBtoHSV(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255))
        hsv.h *= hm
        hsv.s *= sm
        hsv.v *= vm
        
        var rgb = HSVtoRGB(hsv)
        
        return [rgb.r/255, rgb.g/255, rgb.b/255]
    }
}

function mixRGB(a, b, t) {
    if ((typeof(a) !== "undefined") && (typeof(b) !== "undefined") && a.map && b.map) {
        var t1 = 1 - t
        return a.map(function(x, i) { return Math.floor(x * t1 + b[i] * t) })
    }
}

function sumRGB(a, b) {
    if ((typeof(a) !== "undefined") && (typeof(b) !== "undefined") && a.map && b.map) {
        return a.map(function(x, i) { return Math.min(255, x + b[i]) })
    }
}

function hexToRGBArr(hex) {
    if (typeof(hex) !== "undefined") {
        var v = parseInt(hex, 16)
        
        return [(v & 0xFF0000) >> 16, (v & 0xFF00) >> 8, v & 0xFF]
    }
}

function fgColorFromColorMapRule(rule, timeModifier) {
    var col = rule
    
    if ("cycle" in col) {
        var h0 = timeModifier & 0x3F
        var h1 = (timeModifier >> 6) & 0x3F
        var h16 = ((h0 | h1) ^ (timeModifier)) & 0xFFF
        
        var cycle_a = Date.now() / col.msscale + h16 / 16.0
        cycle_a -= Math.trunc(cycle_a)
        var cycle_aneg = 1.0 - cycle_a

        var col0 = hexToColor(col.color)
        var col1 = hexToColor(col.cycle)
        var r0 = ((col0 & 0x00FF0000) >> 16) & 0xFF
        var g0 = ((col0 & 0x0000FF00) >> 8) & 0xFF
        var b0 = ((col0 & 0x000000FF)) & 0xFF
        
        var r1 = ((col1 & 0x00FF0000) >> 16) & 0xFF
        var g1 = ((col1 & 0x0000FF00) >> 8) & 0xFF
        var b1 = ((col1 & 0x000000FF)) & 0xFF
        
        var rt = r0 * cycle_aneg + r1 * cycle_a
        var gt = g0 * cycle_aneg + g1 * cycle_a
        var bt = b0 * cycle_aneg + b1 * cycle_a
        
        return [rt, gt, bt]
    } else {
        return hexToRGBArr(col.color)
    }
}

var ownUsername
var displaySizeX = 96
var displaySizeY = 64
var turn = 0
var minCoords = {x: 0, y: 0}
var particles
var gameStarted = false
var terminal
var showDamage = 0
var useSounds = true
var playerAttrs
var displaySuPow
var titleSprite
var gplusSprite
var twitterSprite
var redditSprite
var lighthouseSprite
var ganymedeSprite
var menuSel = 0
var currentMenu = 0
var lastClick = [-1, -1]
var lastMove = [-1, -1]
var keyboardLook = false
var onClickTarget
var destinationMovement
var destinationPath
var tutorialSeen = false
var tutorialPage = 0

var inspectKeyboardIndex = -1
var inspectKeyboardIdentifier = ""

var weaponSprites = {}

var keybindingsMenuIdentifier = ["Left", "Right", "Up", "Down", "UpLeft", "DownLeft", "UpRight", 
            "DownRight", "Wait", "Inventory", "Fire", "Reload", "View", "Grab", "SuperPow", "Activate", 
            "Prone", "Crouch"]
var keyBindingNames = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
            
var playerClasses = [
        {id: "marine", name: "Marine", description: "Sturdy marines are hard to come by, most people that get enlisted have low IQs and are rather dumb, they think this job is just pulling the trigger and kissing your day bye bye. You have trained to the point that reloading and firing is second nature to you. Also, you ate all your veggies as a kid and so have great health."},
        {id: "heavy", name: "Heavy Weapons", description: "A powered suit needs a lot of strength and a good body build. These qualities, plus the fact that you love barbeque, made you a perfect fit for heavy weaponry. Also, you spent like half a day on the gym for 5 years, so if you say the ammo fits, it fits. Besides, this was the armor that had included 'bathroom' in it, so you don't have to go to the potty so frequently."},
        {id: "swords", name: "Swordmaster", description: "Sushi was your preferred food back on Earth, and you worked on a meat processing factory before enlisting. Cutting things in half was your thing even as a teenager, when you loved to cut open animals to check their internals and identify weak spots. This, coupled with the fact that you're nimble and fast makes you deadly with a sword."},
        {id: "melee", name: "Melee", description: "After winning the triple crown in your league's baseball team, little was left to you to get into the big leagues, however, you had this itch to scratch blunting peeps with a bat, and enlisting was your perfect excuse to batter brains and electronics for a living. Your hobby was watching over-the top anime fights, and so you love hurdling your enemies around."},
        {id: "tech", name: "Technician", description: "Tinkering with clocks, radios and toys was your thing. A toy didn't last much on your hands, as your curiosity was above all your other needs. Good thing there's a lot of sites currently that let you indulge in teardowns and photos of things you can't buy now since you enlisted. Also, implanting that Electromagnetic sensor on your head was good for your survival so far."},
        {id: "engy", name: "Engineer", description: "You enlisted just to be sure that the weapons being used and the computers were up to standard. Turns out, you found out some corrupt superior official smuggling weapons to terrorists and got sent to this hell hole to shut your mouth. After finishing here, you will have a word or two with the general commander, as it seems corruption is the most widespread problem affecting militia."},
        {id: "medic", name: "Medic", description: "When you were a teenager your mom died to cancer and your dad went full depressive and ended with a shotgun on his mouth. This marked you for life and made you take the decision to get on the medical school. Problem is, you didn't have a way to keep paying for the tuition and went on and enlisted to get higher education without paying for it. Now you're on hell. Hindsight is 20/20 they say."},
        {id: "spy", name: "Spy", description: "You left your mother land because you worked on the construction of a tokamak that was a 'strategic' target. Turns out, you love spilling the beans on these strategic stuff, and so, you went undercover in several missions before volunteering to get here, as someone outside the militia offered a nice retirement-leve pay for the secrets of the operation in Ganymede."},
        {id: "explo", name: "Explosives", description: "Festivities where the best for you, specially when they involved fireworks. You loved letting things go boom, so much that your car went boom and you were left severely injured. Your only way to heal was through military-only equipment, and your budget didn't allow private payment hence you enlisted. Now you've got a new spine and a twitch on your remote-trigger."},
        {id: "sniper", name: "Sniper", description: "'Eagle-eye' or 'Bullseye' were your common nicks growing up, because you had this uncanny precision and good long range vision. Your dad tells you to enjoy your vision while you can, as the 40s make everyone's vision go to the dumpster, specially on your family. You're 2 payments ahead on your pair of BioNanotech(c) NuEyes already, and have eyed already some robotic arms for increased precision."},
        {id: "psychic", name: "Psychic", description: "You were born to a weird mix of parents: your mother was a tarot reader and your father an accomplished scientist, or so your mom said. Turns out your father was absent all along, and apparently he did some experiments on you while you were still a fetus, or so you read from your momma's mind, because you have uncanny psychic abilities."},
        {id: "civil", name: "Civilian", description: "A millionaire playboy, a philantropist, an arrogant wunderkind. Those are words that describe perfectly your dad. You've been spoiled beyond repair and you decided it was time to prove yourself, by going into this hell with your trusty 9mm gun. Heh, these golden cradle kids.... Can they ever learn?"},
    ]
var charAttrs = {
    "marine": {
        "HP": {starting: 130, max: 130},
        "AR": {starting: 0, max: 100},
        "ST": {starting: 100, max: 100},
        "PR": {starting: 100, max: 100},
        "SP": {starting: 100, max: 100},
        "Weapon": "MP9 Submachinegun",
        "perks": [
            {txt: "Fast shoot: Shoots without waiting", attr: ["Adrenaline", "Passive"]},
            {txt: "Auto reload: Reloads weapon automatically", attr: ["Adrenaline", "Passive"]},
            {txt: "Free shot: one shot without using ammo", attr: ["Adrenaline", "Active"]},
            {txt: "Free omnishot: shot visibles without using ammo", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "heavy": {
        "HP": {starting: 120, max: 120},
        "AR": {starting: 50, max: 200},
        "ST": {starting: 30, max: 100},
        "PR": {starting: 0, max: 50},
        "SP": {starting: 0, max: 30},
        "Weapon": "Flamethrower",
        "perks": [
            {txt: "Piercing: bullets pierce targets", attr: ["Adrenaline", "Passive"]},
            {txt: "Overloading: reloads weapon beyond capacity", attr: ["Adrenaline", "Passive"]},
            {txt: "Next critical: next shot is critical", attr: ["Adrenaline", "Active"]},
            {txt: "Critical streak: 10 turns of 100% criticals", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "swords": {
        "HP": {starting: 100, max: 100},
        "AR": {starting: 25, max: 50},
        "ST": {starting: 30, max: 100},
        "PR": {starting: 0, max: 30},
        "SP": {starting: 50, max: 200},
        "Weapon": "Katana",
        "perks": [
            {txt: "Super dash: dashes long distance", attr: ["Adrenaline", "Passive"]},
            {txt: "Surround melee: attacks surroinding enemies", attr: ["Adrenaline", "Passive"]},
            {txt: "Directed stab: critical attack on arbitrary target", attr: ["Adrenaline", "Active"]},
            {txt: "Omnislash: slash visibles with 10x critical", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "melee": {
        "HP": {starting: 100, max: 100},
        "AR": {starting: 60, max: 200},
        "ST": {starting: 50, max: 200},
        "PR": {starting: 0, max: 20},
        "SP": {starting: 0, max: 50},
        "Weapon": "9mm pistol",
        "perks": [
            {txt: "Great dash: dashes extra distance", attr: ["Adrenaline", "Passive"]},
            {txt: "Super knockback: knocks enemies through walls", attr: ["Adrenaline", "Passive"]},
            {txt: "Ki blast: near targets get knocked back", attr: ["Adrenaline", "Active"]},
            {txt: "Super Ki blast: visibles 2x knockback + 10x crit.", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "tech": {
        "HP": {starting: 80, max: 80},
        "AR": {starting: 0, max: 80},
        "ST": {starting: 0, max: 80},
        "PR": {starting: 0, max: 100},
        "SP": {starting: 0, max: 100},
        "Weapon": "Gatling laser",
        "perks": [
            {txt: "Comms detect: Detects near enemy comms", attr: ["Adrenaline", "Passive"]},
            {txt: "Wire detect: Detects gadgets' connections", attr: ["Adrenaline", "Passive"]},
            {txt: "Trap detect: Detects traps inside FOV", attr: ["Adrenaline", "Active"]},
            {txt: "Trap steal: Takes ownership of all traps in FOV", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "engy": {
        "HP": {starting: 80, max: 80},
        "AR": {starting: 0, max: 80},
        "ST": {starting: 0, max: 80},
        "PR": {starting: 0, max: 100},
        "SP": {starting: 0, max: 100},
        "Weapon": "xM3 Shotgun",
        "perks": [
            {txt: "CPU Detector: Detects near robotics", attr: ["Adrenaline", "Passive"]},
            {txt: "Comms jamming: Jams enemies' comms", attr: ["Adrenaline", "Passive"]},
            {txt: "Robot hack: Changes faction of one target robot", attr: ["Adrenaline", "Active"]},
            {txt: "Robot worm: Changes faction of robots in 2x FOV", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "medic": {
        "HP": {starting: 80, max: 80},
        "AR": {starting: 100, max: 200},
        "ST": {starting: 0, max: 50},
        "PR": {starting: 0, max: 100},
        "SP": {starting: 0, max: 100},
        "Weapon": "9mm pistol",
        "perks": [
            {txt: "Regeneration: Regenerates health over time", attr: ["Adrenaline", "Passive"]},
            {txt: "Resistance: Gives resistances to near allies", attr: ["Adrenaline", "Passive"]},
            {txt: "Heal: Heals one target to 100% health", attr: ["Adrenaline", "Active"]},
            {txt: "Channel: Allies heal + resist / Enemies weakened", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "spy": {
        "HP": {starting: 80, max: 80},
        "AR": {starting: 0, max: 50},
        "ST": {starting: 0, max: 100},
        "PR": {starting: 0, max: 50},
        "SP": {starting: 0, max: 200},
        "Weapon": "9mm pistol",
        "perks": [
            {txt: "Extra FOV: 20% bigger field of view", attr: ["Passive"]},
            {txt: "Expansive FOV: Field of view expands further", attr: ["Adrenaline", "Passive"]},
            {txt: "Cloaking: Move undetected by enemies", attr: ["Adrenaline", "Passive"]},
            {txt: "Disguise: Changes faction for 10 turns", attr: ["Adrenaline", "Active"]},
            {txt: "Double agent: Changes faction for 100 turns", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "explo": {
        "HP": {starting: 110, max: 110},
        "AR": {starting: 50, max: 200},
        "ST": {starting: 50, max: 100},
        "PR": {starting: 0, max: 30},
        "SP": {starting: 0, max: 50},
        "Weapon": "H80 RPG",
        "perks": [
            {txt: "Trap detection: Detects near traps", attr: ["Adrenaline", "Passive"]},
            {txt: "???: ???", attr: ["Adrenaline", "Passive"]},
            {txt: "Mine: Drops one mine trap", attr: ["Adrenaline", "Active"]},
            {txt: "Cluster mine: Drops 15 mines in FOV", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "sniper": {
        "HP": {starting: 80, max: 80},
        "AR": {starting: 0, max: 100},
        "ST": {starting: 0, max: 100},
        "PR": {starting: 75, max: 200},
        "SP": {starting: 0, max: 50},
        "Weapon": "xM50 Rifle",
        "perks": [
            {txt: "Super FOV: 60% bigger field of view", attr: ["Passive"]},
            {txt: "Expansive FOV: Field of view expands further", attr: ["Adrenaline", "Passive"]},
            {txt: "Extra precision: Precision enhanced significantly", attr: ["Adrenaline", "Passive"]},
            {txt: "Aim: 100% precision + 100% critical on next shot", attr: ["Adrenaline", "Active"]},
            {txt: "Bullseye: Shots 5 targets in FOV / 100% precision", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "psychic": {
        "HP": {starting: 70, max: 70},
        "AR": {starting: 0, max: 50},
        "ST": {starting: 0, max: 100},
        "PR": {starting: 0, max: 130},
        "SP": {starting: 0, max: 200},
        "Weapon": "9mm pistol",
        "perks": [
            {txt: "Clairvoyance: Can see through walls", attr: ["Adrenaline", "Passive"]},
            {txt: "Sould detect: Detects near organics", attr: ["Adrenaline", "Passive"]},
            {txt: "Hypnosis: Changes faction of a organic enemy", attr: ["Adrenaline", "Active"]},
            {txt: "Omen: Changes faction of organics in 2x FOV", attr: ["FullAdrenaline", "Active"]}
        ]
    },
    "civil": {
        "HP": {starting: 50, max: 50},
        "AR": {starting: 0, max: 25},
        "ST": {starting: 0, max: 25},
        "PR": {starting: 0, max: 25},
        "SP": {starting: 0, max: 25},
        "Weapon": "9mm pistol",
        "perks": [
            {txt: "Crappy FOV: 33% smaller field of view", attr: ["Passive"]},
            {txt: "???: ???", attr: ["Adrenaline", "Passive"]},
            {txt: "???: ???", attr: ["Adrenaline", "Passive"]},
            {txt: "Reveal: Reveals position to enemies 2x FOV", attr: ["Adrenaline", "Active"]},
            {txt: "Berserk: Autoshoots everything in sight", attr: ["FullAdrenaline", "Active"]}
        ]
    }
}
var itemsPerMenu = [(typeof(require) !== "undefined")?5:4, playerClasses.length + 2, 6, 1, 3, 20]
var menuOptionsNumber = itemsPerMenu[0]

var level = []
var levelTileset = ""

var tilesetDescription = {
    "base": {
        24: "Lever",
        233: "Barrel",
        61: "Closed door",
        95: "Open door",
        62: "Downstairs"
    },
    "lava": {
        24: "Lever",
        233: "Barrel",
        61: "Closed door",
        95: "Open door",
        62: "Downstairs"
    },
    "cave": {
        24: "Lever",
        233: "Barrel",
        61: "Closed door",
        95: "Open door",
        62: "Downstairs"
    }
}

var tilePassabilityOverrides = {
    61: {val: 1, costMult: 2.0, costAdd: 10}
}

var tilePixActions = {
    24: "Activate",
    61: "Open door",
    95: "Close door",
    62: "Exit level"
}

var cssRules = {}

var playerDivs = {}

var queuedAnns = []
var queuedInterval = null
var playerPickClass = "marine"
var currentTips = []
var clearTipsTimeout = null
var showingInventory = false
var inventoryIndex = 0
var inventoryList
var opsColsFg = {true: [0, 255, 0], false: [64, 96, 64]}
var opsColsBg = {true: [64, 64, 128], false: [32, 32, 32]}
var opsColsLuma = {true: [255, 255, 255], false: [16, 16, 16]}
var menuStars = []

var announcements = []
var lastAnnTmstmp = 0

var descriptions = []
var warnings = []
var justWarned = false
var actionMenuShown = false
var actionMenuCenter = [0, 0]
var actionMenuActions
var askingShortcutIndex

var UI_ALPHA = 0.8

var currentPkts = []

function queueAnnouncements(msgs) {
    lastAnnTmstmp = Date.now()
    announcements = announcements.concat(msgs.map(function(m, i) { return {tmstmp: lastAnnTmstmp + i * 3000, msg: m} }))
}

function announceMsg(msg) {
    lastAnnTmstmp = Date.now()
    announcements.push({tmstmp: lastAnnTmstmp, msg: msg})
}

function pickClass(cls) {
    playerPickClass = cls
}

function passability(tile) {
    if (tile.tile in tilePassabilityOverrides) {
        return tilePassabilityOverrides[tile.tile]
    } else {
        return {val: tile.pss, costMult: 1, costAdd: 0}
    }
}

var astarIteration = 0
var lastTracedPath
function clearLastTracedPath() {
    if (typeof(lastTracedPath) !== "undefined") {
        for (var i=0; i < lastTracedPath.length; i++) {
            var p = lastTracedPath[i]
            var t = level[p.y][p.x]
            
            if (typeof(t.hl) !== "undefined") {
                delete t.hl
            }
        }
    }
}

function astarTraverse(agent, start, target, scores) {
    astarIteration++
    var openSet = []
    var pss = passability
    
    clearLastTracedPath()
    
    var euristicRelax = 0.8
    var includeOnOpenSet = function(item) {
        var i = 0
        while (i < openSet.length) {
            if ((openSet[i].carriedCost * euristicRelax) > item.carriedCost) {
                var tail = openSet.splice(i)
                openSet = openSet.concat([item], tail)
                return
            }
            i++
        }
        
        openSet = openSet.concat([item])
    }
    
    var expand = function(elem, level) {
        for (var dy=0; dy <= 2; dy++) {
            var uy = dy
            if (uy == 2) { // Expand first the straight sections
                uy = -1
            }
            var ny = elem.y + uy
            if ((ny >= 0) && (ny < level.length)) {
                var row = level[ny]
                for (var dx=0; dx <= 2; dx++) {
                    var ux = dx
                    if (ux == 2) { // Expand first the straight sections
                        ux = -1
                    }
                    var nx = elem.x + ux
                    if (!((dx == 0) && (dy == 0)) && (nx >= 0) && (nx < row.length)) {
                        var tile = row[nx]
                        
                        if (!('astarIteration' in tile) || (tile.astarIteration < astarIteration)) {
                            tile.astarIteration = astarIteration
                            var pa = pss(tile)
                            var p = pa.val
                            
                            var difX = nx - target.x
                            var difY = ny - target.y
                            var euclideanCost = Math.sqrt(difX * difX + difY * difY)
                            
                            var newCost = elem.carriedCost + euclideanCost * pa.costMult + pa.costAdd
                            var discard = false
                            
                            if (p == 1) {
                                if (tile.damage) {
                                    if (tile.damage <= agent.attrs.hp.pos) {
                                        newCost += tile.damage * 100
                                    } else {
                                        discard = true
                                    }
                                }
                            } else if (p == 2) {
                                if ((typeof(tile.character) != "undefined") && (tile.character != null)) {
                                    if ((tile.character.attrs) && (tile.character.attrs.faction != agent.attrs.faction)) {
                                        if ((typeof(scores) !== "undefined") && ('enemy' in scores)) {
                                            newCost += scores.enemy(tile.character)
                                        } else {
                                            discard = true
                                        }
                                    } else {
                                        discard = true
                                    }
                                } else {
                                    discard = true
                                }
                            } else if (p == 0) {
                                discard = true
                            } else if (p == 3) {
                                newCost += euclideanCost * 3
                            } else if ((typeof(tile.item) != "undefined") && (tile.item != null)) {
                                if ((typeof(scores) !== "undefined") && ('item' in scores)) {
                                    newCost += scores.item(tile.item)
                                }
                            }
                            
                            if (!discard) {
                                includeOnOpenSet({x: nx, y: ny, carriedCost: newCost, history: elem.history.concat([elem])})
                            }
                        }
                    }
                }
            }
        }
    }
    
    var path
    expand({x: start.x, y: start.y, carriedCost: 0, history: []}, level)
    while (openSet.length > 0) {
        var nextElement = openSet.shift()
        
        if ((nextElement.x == target.x) && (nextElement.y == target.y)) {
            path = nextElement.history.concat([nextElement])
            break
        } else {
            expand(nextElement, level)
        }
    }
    
    if (path) {
        path.shift()
        lastTracedPath = path.map(function(e) { return {x: e.x, y: e.y} })
        return lastTracedPath
    }
}

function bresenhamsTrace(agent, start, target, energy) {
    clearLastTracedPath()
    
    var path = bresenhamsEvaluate(start.x, start.y, target.x, target.y, energy, function(tile, x, y) {
        return passability(tile).val != 1
    })
    
    lastTracedPath = path
    
    return path
}

function bresenhamsEvaluate(x0, y0, x1, y1, energy, callback) {
    // Callback should be of the form
    //   function(tile, x, y)
    // And return true if it should stop evaluating the line
    
    var initialEnergy = energy
    var result = []
    
	if (!energy) {
		energy = 1000
	}
	
    if (x0 < 0) {
        x0 = 0
    } else if (x0 >= level[0].length) {
        x0 = level[0].length - 1
    }
    
    if (x1 < 0) {
        x1 = 0
    } else if (x1 >= level[0].length) {
        x1 = level[0].length - 1
    }
    
    if (y0 < 0) {
        y0 = 0
    } else if (y0 >= level.length) {
        y0 = level.length - 1
    }
    
    if (y1 < 0) {
        y1 = 0
    } else if (y1 >= level.length) {
        y1 = level.length - 1
    }

    var dx = x1 - x0
    var dy = y1 - y0
    var lx, ly
    var path = 0
    
    if ((dx == 0) && (dy == 0)) {
        result.push({x: x1, y: y1})
    } else if (dy == 0) {
        // Horizontal line, easiest
        path = 1
        var row = level[Math.floor(y0)]
        var ix = (dx > 0)?1:-1
        dx = Math.abs(dx)
        
        var x = x0 + ix
        while ((x >= 0) && (x < row.length) && (energy > 0)) {
            path = 1001
            lx = x
            ly = y0
            
			var tile = row[Math.floor(x)]
            
            var res = callback(tile, Math.floor(x), Math.floor(y0))
            result.push({x: Math.floor(x), y: Math.floor(y0)})
            if (res) {
                break
            }
            
            x += ix
			energy--
        }
    } else if (dx == 0) {
        // Vertical line, easy
        path = 2
        
        var iy = (dy > 0)?1:-1
        dy = Math.abs(dy)
        
        var y = y0 + iy
        while ((y >= 0) && (y < level.length) && (energy > 0)) {
            lx = x0
            ly = y
            
			var tile = level[Math.floor(y)][Math.floor(x0)]
			var res = callback(tile, Math.floor(x0), Math.floor(y))
            result.push({x: Math.floor(x0), y: Math.floor(y)})
            if (res) {
                break
            }
            
            y += iy
			energy--
        }
    } else {
        // Run the algorithm
        path = 3
        
        var ix = (dx > 0)?1:-1
        var iy = (dy > 0)?1:-1
        var error = 0
        
        if (Math.abs(dx) > Math.abs(dy)) {
            var derror = Math.abs(dy/dx)
            var y = y0
            var x=x0+ix
            
            while ((x >= 0) && (x < level[0].length) && (y >= 0) && (y < level.length) && (energy > 0)) {
                lx = x
                ly = y
                
                error += derror
                if (error > 0.5) {
                    y += iy
                    error -= 1.0
                }
                
                if ((x >= 0) && (x < level[0].length) && (y >= 0) && (y < level.length)) {
					var tile = level[Math.floor(y)][Math.floor(x)]
					var res = callback(tile, Math.floor(x), Math.floor(y))
                    result.push({x: Math.floor(x), y: Math.floor(y)})
                    if (res) {
                        break
                    }
                }
                
                x+=ix
				energy--
            }
        } else if (Math.abs(dx) < Math.abs(dy)) {
            var derror = Math.abs(dx/dy)
            var x = x0
            var y=y0+iy
            while ((x >= 0) && (x < level[0].length) && (y >= 0) && (y < level.length) && (energy > 0)) {
                error += derror
                if (error > 0.5) {
                    x += ix
                    error -= 1.0
                }
                
                lx = x
                ly = y
                
                if ((x >= 0) && (x < level[0].length) && (y >= 0) && (y < level.length)) {
					var tile = level[Math.floor(y)][Math.floor(x)]
					var res = callback(tile, Math.floor(x), Math.floor(y))
                    result.push({x: Math.floor(x), y: Math.floor(y)})
                    if (res) {
                        break
                    }
                }
                
                y+=iy
				energy--
            }
        } else if (Math.abs(dx) == Math.abs(dy)) {
            var x = x0+ix
            var y = y0+iy
            while ((x >= 0) && (x < level[0].length) && (y >= 0) && (y < level.length) && (energy > 0)) {
				var tile = level[Math.floor(y)][Math.floor(x)]
				
                lx = x
                ly = y
                
                var res = callback(tile, Math.floor(x), Math.floor(y))
                result.push({x: Math.floor(x), y: Math.floor(y)})
                if (res) {
                    break
                }
                
                x += ix
                y += iy
				energy--
            }
        }
    }
    
    if (isNaN(lx) || isNaN(ly)) {
        console.log("NaN on failover tracing " + lx + " " + ly + "; Path: " + path + "; NRG: " + initialEnergy)
    }
    
    return result
}

function start() {
    descriptions = []
    warnings = []
    displaySuPow = 0
    
    localStorage.username = ownUsername
    localStorage.chartype = playerPickClass
    
    if (bgm) {
        bgm.stop()
    }
    
    send({
        type: 'start',
        username: ownUsername,
        player_class: playerPickClass
    })
    
    return false
}

function pos(ndx, ndy, shifted) {
    clearLastTracedPath()
    descriptions = []
    warnings = []
    
    var npos = {x: player.pos.x, y: player.pos.y}
    if (typeof(ndx) != 'undefined') {
        npos.x += ndx
    }
    
    if (typeof(ndy) != 'undefined') {
        npos.y += ndy
    }
    
    send({
        type: 'pos',
        pos: npos,
        special: shifted
    })
}

function describe(x, y) {
    var desc = {}
    descriptions = []
    if (justWarned) {
        justWarned = false
    } else {
        warnings = []
    }
    
    if ((y >= 0) && (y < level.length)) {
        var row = level[y]
        
        if ((x >= 0) && (x < row.length)) {
            var tile = row[x]
            
            var description = []
            
            if (tile.turn != turn) {
                description.push({text: "You saw:"})
            } else {
                description.push({text: "You see:"})
            }
            
            if ("character" in tile) {
                var additional = ""
                
                if (tile.character.aggro > 0) {
                    if (tile.character.aggro > 25) {
                        additional = " (Very aggressive)"
                    } else {
                        additional = " (Aggressive)"
                    }
                }
                
                if (("type" in tile.character) && (tile.character.type == 'ai')) {
                    if (tile.character.username) {
                        description.push({text: (/(.*)[N]*.*/).exec(tile.character.username).pop().trim() + additional})
                    } else {
                        description.push({text: "Unnamed enemy" + additional})
                    }
                } else {
                    if ((x == player.pos.x) && (y == player.pos.y)) {
                        description.push({text: "Yourself" + additional})
                    } else if (!tile.character.username) {
                        description.push({text: "Player " + tile.character.username + additional})
                    } else {
                        description.push({text: "A Player" + additional})
                    }
                }
                
                if ("color" in tile.character) {
                    description[description.length-1].fg = tile.character.color
                }
            }
            
            if ("item" in tile) {
                if ("name" in tile.item) {
                    description.push({text: tile.item.name})
                } else if ("ammoType" in tile.item) {
                    description.push({text: tile.item.ammoType + " charger"})
                }
                
                if ("cssClass" in tile.item) {
                    description[description.length-1].cssClass = tile.item.cssClass
                }
            }
            
            if ("debris" in tile) {
                if ("type" in tile.debris) {
                    description.push({text: tile.debris.type})
                }
                
                if ("color" in tile.debris) {
                    description[description.length-1].fg = tile.debris.color
                }
            }
            
            var hazardDescribed = false
            if ("cssClass" in tile) {
                if (tile.cssClass == "acid") {
                    hazardDescribed = true
                    description.push({text: "Acid", cssClass: "acid"})
                } else if (tile.cssClass == "lava") {
                    hazardDescribed = true
                    description.push({text: "Lava", cssClass: "lava"})
                } else if (tile.cssClass == "plasma") {
                    hazardDescribed = true
                    description.push({text: "Plasma", cssClass: "plasma"})
                }
            }
            
            if (!hazardDescribed && ("damage" in tile)) {
                description.push({text: "Hazardous floor", cssClass: "lava"})
            }
            
            if (levelTileset in tilesetDescription) {
                var thisTilesetDescriptor = tilesetDescription[levelTileset]
                
                if (tile.tile in thisTilesetDescriptor) {
                    var specificTileDescriptor = thisTilesetDescriptor[tile.tile]
                    var fgbgdesc = tile.fg + "-" + tile.bg
                    
                    if (typeof(specificTileDescriptor[fgbgdesc]) != "undefined") {
                        description.push({text: specificTileDescriptor[fgbgdesc]})
                    } else if (typeof(specificTileDescriptor[tile.fg]) != "undefined") {
                        description.push({text: specificTileDescriptor[tile.fg]})
                    } else if (typeof(specificTileDescriptor[tile.bg]) != "undefined") {
                        description.push({text: specificTileDescriptor[tile.bg]})
                    } else if (typeof(specificTileDescriptor["default"]) != "undefined") {
                        description.push({text: specificTileDescriptor["default"]})
                    } else {
                        description.push({text: specificTileDescriptor})
                    }
                }
            }
            
            desc.pos = [lastMove[0], lastMove[1] - description.length - 1]
            desc.lines = description
            
            descriptions.push(desc)
            
            var playerFiring = (typeof(player.firing) !== "undefined") && (player.firing !== "no")
            if (!actionMenuShown && !playerFiring) {
                var path = astarTraverse({attrs: playerAttrs}, {x: player.pos.x, y: player.pos.y}, {x: x, y: y})
                if (path) {
                    for (var i=0; i < path.length; i++) {
                        var p = path[i]
                        var tile = level[p.y][p.x]
                        
                        tile.hl = {t: turn, col: [255, 0, 0]}
                    }
                }
            } else if (playerFiring) {
                var path = bresenhamsTrace({attrs: playerAttrs}, {x: player.pos.x, y: player.pos.y}, {x: x, y: y}, currentWeapon.range || 0)
                if (path) {
                    for (var i=0; i < path.length; i++) {
                        var p = path[i]
                        var tile = level[p.y][p.x]
                        
                        tile.hl = {t: turn, col: [0, 255, 0]}
                    }
                }
            }
        }
    }
}

function prone() {
    descriptions = []
    warnings = []
    
	send({
        type: 'prone'
    })
}

function crouch() {
    descriptions = []
    warnings = []
    
	send({
        type: 'crouch'
    })
}

function collectVisibleEnemies() {
    var ret = {}
    
    for (var i=0; i < level.length; i++) {
        var row = level[i]
        for (var j=0; j < row.length; j++) {
            var tile = row[j]
            
            if ((tile.turn == turn) && 
                (typeof(tile.character) !== "undefined") && (tile.character.aggro > 0) &&
                (typeof(tile.light) !== "undefined") && (Math.max(tile.light.color[0], tile.light.color[1], tile.light.color[2]) > 128)) {
                ret[tile.character.username] = {trn: turn, x: j, y: i}
            }
        }
    }
    
    return ret
}

var expectedPlayerPos
var onReachCallback
var lastEnemies = {}
var lastPosTryMove = [-1, -1]
function tryMoveTowardsDestination() {
    descriptions = []
    warnings = []
    
    if ((typeof(destinationPath) !== "undefined") && (destinationPath.length > 0)) {
        // Retrace the path, everything could have changed
        var lastStep = destinationPath[destinationPath.length - 1]
        var newPath = astarTraverse({attrs: playerAttrs}, {x: player.pos.x, y: player.pos.y}, {x: lastStep.x, y: lastStep.y})
        
        destinationPath = newPath
        
        var newEnemiesVisible = collectVisibleEnemies()
        var newEnemiesVisLean = {}
        var hasNewEnemies = false
        
        for (x in newEnemiesVisible) {
            newEnemiesVisLean[x] = newEnemiesVisible[x].trn
            // Enemies still visible shouldn't affect processing
            var nev = newEnemiesVisible.hasOwnProperty(x)
            var lev = lastEnemies.hasOwnProperty(x)
            
            if (nev && lev) {
                lastEnemies[x] = newEnemiesVisible[x].trn
            } else if (nev && !lev) {
                hasNewEnemies = true
            }
        }
        
        for (x in lastEnemies) {
            // Enemies that aren't visible for a certain number of turns shouldn't affect processing
            if ((turn - lastEnemies[x]) > 5) {
                delete lastEnemies[x]
            }
        }
        
        if (hasNewEnemies) {
            for (x in lastEnemies) {
                delete newEnemiesVisible[x]
            }
            
            for (x in newEnemiesVisible) {
                var tile = level[newEnemiesVisible[x].y][newEnemiesVisible[x].x]
                tile.hl = {t: turn, col: {"color": "FF2200", "cycle": "FFFF00", "msscale": 600}}
            }
            
            for (x in newEnemiesVisLean) {
                if (!lastEnemies.hasOwnProperty(x)) {
                    lastEnemies[x] = newEnemiesVisLean[x]
                }
            }
            destinationPath = undefined
            
            return
        }
        
        if (typeof(destinationPath) === "undefined") {
            return
        }
        
        destinationMovement = destinationPath.shift()
    }
    
    if ((typeof(destinationMovement) !== "undefined")&&
        ((typeof(expectedPlayerPos) === "undefined")||
         ((expectedPlayerPos[0] == player.pos.x)&&
          (expectedPlayerPos[1] == player.pos.y))||
         (level[expectedPlayerPos[1]][expectedPlayerPos[0]].tile === 95)) ) {
        var dx = 0, dy = 0
        
        if (player.pos.x < destinationMovement.x) {
            dx = 1
        } else if (player.pos.x > destinationMovement.x) {
            dx = -1
        }
        
        if (player.pos.y < destinationMovement.y) {
            dy = 1
        } else if (player.pos.y > destinationMovement.y) {
            dy = -1
        }
        
        if ((dx != 0) || (dy != 0)) {
            var newLastPosTryMove = [destinationMovement.x, destinationMovement.y]
            var tile = level[destinationMovement.y][destinationMovement.x]
            
            if ((typeof(tile.damage) !== "undefined") && (tile.damage > 0)) {

                if ((newLastPosTryMove[0] != lastPosTryMove[0]) ||
                    (newLastPosTryMove[1] != lastPosTryMove[1])) {
                    console.log('Prompting confirmation from the player for walking over hazard')
                    destinationMovement = undefined
                    expectedPlayerPos = undefined
                    lastPosTryMove = newLastPosTryMove
                    
                    var descX = lastPosTryMove[0] - player.pos.x + player.cpos.x
                    var descY = lastPosTryMove[1] - player.pos.y + player.cpos.y
                    var arrowPrex = " "
                    var arrowSufx = " "
                    
                    if (lastPosTryMove[1] != player.pos.y) {
                        if ((lastPosTryMove[0] + 31) < displaySizeX) {
                            descX += 1
                            arrowPrex = "\u2190"
                        } else {
                            descX -= 30
                            arrowSufx = "\u2192"
                        }
                    } else {
                        if ((lastPosTryMove[0] + 31) < displaySizeX) {
                            if (lastPosTryMove[0] == 0) {
                                descY += 1
                                arrowPrex = "\u2191"
                            } else {
                                descY -= 1
                                arrowPrex = "\u2193"
                            }
                        } else {
                            descX -= 29
                            if (lastPosTryMove[0] == 0) {
                                descY += 1
                                arrowSufx = "\u2191"
                            } else {
                                descY -= 1
                                arrowSufx = "\u2193"
                            }
                        }
                    }
                    
                    var warn = {}
                    warn.pos = [descX, descY]
                    warn.lines = [{text: arrowPrex + "Confirm walking over hazard!" + arrowSufx}]
                    
                    warnings.push(warn)
                    justWarned = true
                    
                    if (onReachCallback) {
                        onReachCallback("damage")
                        onReachCallback = undefined
                    }
                    
                    return
                }
            }
            
            lastPosTryMove = [destinationMovement.x, destinationMovement.y]
            
            expectedPlayerPos = [player.pos.x + dx, player.pos.y + dy]
            pos(dx, dy)
        } else {
            destinationMovement = undefined
            expectedPlayerPos = undefined
            
            if (onReachCallback) {
                onReachCallback()
                onReachCallback = undefined
            }
        }
    } else {
        expectedPlayerPos = undefined
        destinationMovement = undefined
        
        if (onReachCallback) {
            onReachCallback("unexpected")
            onReachCallback = undefined
        }
    }
}

function activateMenuAction(i) {
    actionMenuShown = false
    lastClick = [-1, -1]
    
    if (mouseActions[actionMenuActions[i].text]) {
        var pos = actionMenuActions[i].pos || {x: -1, y: -1} // A good fallback to avoid unnecessary logic
        mouseActions[actionMenuActions[i].text](pos.x, pos.y, actionMenuActions[i])
    }
}

function use() {
    descriptions = []
    warnings = []
    
    if (gameStarted) {
        if (showingInventory) {
            if ((actionMenuShown) && (actionMenuActions) && (menuSel >= 0) && (menuSel < actionMenuActions.length)) {
                // Activate the option
                activateMenuAction(menuSel)
            } else {
                activateInventory(inventoryIndex)
            }
        } else if (keyboardLook) {
            if ((typeof(onClickTarget) != "undefined") && (onClickTarget != null)) {
                var x = player.pos.x + (lastMove[0] - player.cpos.x)
                var y = player.pos.y + (lastMove[1] - player.cpos.y)
                onClickTarget(x, y, true)
            } else {
                menuSel = -1
                clickCell(lastMove[0], lastMove[1])
            }
            
            shutdownKeyboardLook()
        } else if ((actionMenuShown) && (actionMenuActions) && (menuSel >= 0) && (menuSel < actionMenuActions.length)) {
            // Activate the option
            activateMenuAction(menuSel)
        } else {
            send({
                type: 'use'
            })
        }
    } else {
        menuUse()
    }
}

function useInventory(idx) {
    send({
        type: 'useInventory',
        index: idx
    })
}

function drop(idx) {
    send({
        type: 'dropInventory',
        index: idx
    })
}

function unload(idx) {
    send({
        type: 'unloadInventory',
        index: idx
    })
}

function inspect(idx) {
    send({
        type: 'inspectInventory',
        index: idx
    })
}

function askShortcut(idx) {
    askingShortcutIndex = idx
}

function grab() {
    descriptions = []
    warnings = []
    
    send({
        type: 'grab'
    })
}

function fire(alternate, pos) {
    var ret
    descriptions = []
    warnings = []
    
    if (alternate && ((typeof(player.firing) == "undefined") || (player.firing != 'alternate'))) {
        player.firing = 'alternate'
    } else if ((typeof(player.firing) == "undefined") || (player.firing != 'primary')) {
        player.firing = 'primary'
    }
    
    var fireFunc = function(x, y) {
        send({
            type: 'fire',
            tgt: {x: x, y: y},
            alt: alternate
            })
            
        shutdownKeyboardLook()
    }
    
    if (!pos) {
        var didntHaveLook = !keyboardLook
        waitTarget(fireFunc)
        
        if (didntHaveLook) {
            fnCommands.toggleKeyboardLook()
        }
        ret = "cursor"
        announceMsg("Click over a cell to target")
        
        var ntgt = nearestTarget()
        
        if (typeof(ntgt) !== "undefined") {
            lastMove = [ntgt.x, ntgt.y]
            describe(ntgt.x + player.pos.x - player.cpos.x, ntgt.y + player.pos.y - player.cpos.y)
        }
        
    } else {
        fireFunc(pos.x, pos.y)
        player.firing = 'no'
        
        shutdownKeyboardLook()
    }
    
    return ret
}

function superPower(alternate) {
    send({
        type: 'supow',
        alt: alternate
        })
}

function cheat(fn, data) {
    var msg = {
        type: 'cheat',
        fn: fn
    }
    if (data) {
        msg.data = data
    }
    send(msg)
}

function reload(alternate) {
    descriptions = []
    warnings = []
    
    send({
        type: 'reload',
		alt: alternate
    })
}

function updateInventory() {
    descriptions = []
    warnings = []
    
    send({
        type: 'inventory'
    })
}

function activateInventory(idx) {
    descriptions = []
    warnings = []

    var actions = []
    
    actions.push({"text": "Use"})
    actions.push({"text": "Drop"})
    actions.push({"text": "Unload"})
    actions.push({"text": "Inspect"})
    actions.push({"text": "Shortcut"})
    actions.push({"text": "Close", "bg": {true: [192, 64, 64], false: [48, 0, 0]}})
    actionMenuShown = true
    actionMenuActions = actions
    actionMenuCenter = lastClick
}

function clearTips() {
    descriptions = []
    warnings = []
}

function showTips() {
    if (clearTipsTimeout != null) {
        clearTimeout(clearTipsTimeout)
        clearTips()
        return
    }


    // First, collect all the "tippable" entities
    // TODO: The items should be classified if they are on sight or not
    var tip_items = []
    for (var y=0; y < displaySizeY; y++) {
        var row = level[y + minCoords.y]
        for (var x=0; x < displaySizeX; x++) {
            var tile = row[x + minCoords.x]
            
            if (tile.character || tile.item) {
                var o = absolutePosToWindow(x + minCoords.x, y + minCoords.y)
                o.tile = tile
                tip_items.push(o)
            }
        }
    }
    
    // TODO: Check that the boxes don't collide!
    var bod = $(document.body)
    for (var i=0; i < tip_items.length; i++) {
        var o = tip_items[i]
        var tip = $("<div>")
        if ((typeof(o.tile.character) != "undefined") && (o.tile.character != null)) {
            tip.text(o.tile.character.username)
        }
        
        if ((typeof(o.tile.item) != "undefined") && (o.tile.item != null)) {
            tip.text(o.tile.item.name || o.tile.item.ammoType)
        }
        
        tip.css('position', 'fixed')
        tip.addClass('tip')
        o.left += 16
        tip.offset(o)
        bod.append(tip)
        currentTips.push(tip)
    }
    
    clearTipsTimeout = setTimeout(clearTips, 1000)
}

function toggleInventory() {
    descriptions = []
    warnings = []
    actionMenuShown = false
    lastClick = [-1, -1]
    
    if (showingInventory) {
        showingInventory = false
    } else {
        updateInventory()
        showingInventory = true
    }
}

function drawInventory() {
    drawAsciiText(1, 0, 'Inventory', [0, 255, 0], [0, 0, 0])
    if (inventoryList) {
        inventoryIndex = Math.min(Math.max(0, inventoryIndex), inventoryList.length - 1)
        
        if (!actionMenuShown && (lastMove[1] >= 2) && (lastMove[0] >= 1) && (lastMove[0] < 64)) {
            var ni = Math.floor((lastMove[1] - 2)/2)
            
            if (ni < 0) {
                ni = -1
            } else if (ni >= inventoryList.length) {
                ni = -1
            }
            
            inventoryIndex = ni
        }
        
        for (var i=0; i < inventoryList.length; i++) {
            var item = inventoryList[i]
            var txt = '[ ] '
            var fgcol = [0, 0, 0]
            
            if (item.type == 'ammo') {
                var mults = ""
                if ((item.minDamageMult != 1) || (item.maxDamageMult != 1)) {
                    mults = 'x' + item.minDamageMult
                    
                    if (item.minDamageMult != item.maxDamageMult) {
                        mults += '-' + item.maxDamageMult
                    }
                }
                
                txt += item.ammoType + ' (' + item.amount + ') ' + mults
                fgcol = [153, 153, 0]
            } else if (item.type == 'weapon') {
                var ammo = ""
                if (item.ammoMax > 0) {
                    ammo = ' (' + item.ammoType + ' ' + item.ammo + '/' + item.ammoMax+ ')'
                }
                txt += item.name + ' dmg: ' + item.damage[0] + '-' + item.damage[1] + ammo
                fgcol = [221, 0, 0]
            } else {
                txt += item.name
                fgcol = [64, 192, 0]
            }
            
            var bgCol = opsColsBg[i == inventoryIndex]
            
            if ((typeof(item.cssClass) !== "undefined") && (item.identified)) {
                if (item.cssClass in colorMap) {
                    fgcol = fgColorFromColorMapRule(colorMap[item.cssClass], i * 5)
                }
            } else if ((typeof(item.identified) !== "undefined") && !item.identified) {
                fgcol = [255, 0, 0]
                bgCol = {true: [128, 0, 0], false: [64, 0, 0]}[i == inventoryIndex]
            }
            
            drawAsciiText(1, 2 + i * 2, txt, fgcol, bgCol)
            terminal.setPixel(2, 2 + i * 2, item.pix, fgcol, bgCol)
            
            if (!actionMenuShown && (lastClick[0] != -1) && (lastClick[1] != -1) &&
                (lastClick[0] == lastMove[0]) && (lastClick[1] == lastMove[1])&&
                (inventoryIndex == i)) {
                use()
                lastClick = [-1, -1]
            }
        }
        
        if ((typeof(askingShortcutIndex) !== "undefined") && (askingShortcutIndex >= 0)) {
            var bx = displaySizeX/2 - 24
            var by = displaySizeY/2 - 16
            var fgcol = [96, 255, 96]
            var altfgcol = [96, 128, 255]
            var bgcol = [32, 32, 32]
            
            var pulseVal = Math.floor((Math.sin(Date.now() / 100) +  1) * 24)
            var pulseColor = [pulseVal, 32 + pulseVal, 32]
            
            drawBox(bx, by, 48, 32, bgcol)
            
            
            drawAsciiText(displaySizeX/2 - 8, by + 1, "Select a Number:", fgcol, bgcol)
            
            for (var i=1; i <= 10; i++) {
                var shrtItemName = "-- No item selected --"
                drawAsciiText(displaySizeX/2 - 22, by + 3 + i * 2, "[" + (i % 10) + "] " + shrtItemName, fgcol, bgcol)
                drawAsciiText(displaySizeX/2 - 22, by + 3 + i * 2, "[" + (i % 10) + "]", altfgcol, pulseColor)
            }
        }
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 24, displaySizeY - 4, "Close", 16, opsColsFg, opsColsBg, 0)) {
        showingInventory = false
        actionMenuShown = false
    }
}

function cancelTarget() {
    onClickTarget = undefined
    player.firing = 'no'
}

function nearestTarget() {
    var sightFov = player.fov
    var sf2 = sightFov * sightFov
    var foundTarget = false
    var lightThreshold = 96
    var selx, sely, seld2 = sf2*2
    
    for (var y=-sightFov; y < sightFov; y++) {
        var ty = player.pos.y + y
        
        if ((ty >= 0) && (ty < level.length)) {
            var yy = y*y
            for (var x=-sightFov; x < sightFov; x++) {
                var tx = player.pos.x + x
                if ((tx >= 0) && (tx < level[0].length)) {
                    var d2 = x*x + yy
                    
                    if ((d2 <= sf2) && (d2 != 0)) {
                        var tile = level[ty][tx]
                        
                        if (tile.character && (tile.turn == turn)) {
                            // TODO: Check the character is aggresive to us
                            
                            var newFoundLight = Math.max(tile.light.color[0], tile.light.color[1], tile.light.color[2])
                            
                            if ((d2 < seld2) && (newFoundLight > lightThreshold)) {
                                selx = tx
                                sely = ty
                                seld2 = d2
                                foundTarget = true
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (foundTarget) {
        return {x: selx - player.pos.x + player.cpos.x, y: sely - player.pos.y + player.cpos.y}
    }
}

function waitTarget(fn) {
    if (onClickTarget) {
        // Autoselect target
        var sightFov = player.fov
        var sf2 = sightFov * sightFov
        var foundTarget = false
        var selx, sely, seld2 = sf2*2
        
        for (var y=-sightFov; y < sightFov; y++) {
            var ty = player.pos.y + y
            
            if ((ty >= 0) && (ty < level.length)) {
                var yy = y*y
                for (var x=-sightFov; x < sightFov; x++) {
                    var tx = player.pos.x + x
                    if ((tx >= 0) && (tx < level[0].length)) {
                        var d2 = x*x + yy
                        
                        if ((d2 <= sf2) && (d2 != 0)) {
                            var tile = level[ty][tx]
                            
                            if (tile.character) {
                                // TODO: Check the character is aggresive to us
                                if (d2 < seld2) {
                                    selx = tx
                                    sely = ty
                                    seld2 = d2
                                    foundTarget = true
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if (foundTarget) {
            onClickTarget(selx, sely, true)
            player.firing = "no"
        }
        shutdownKeyboardLook()
    } else {
        // Wait target selection
        onClickTarget = function(x, y, direct) {
            // Correct x and y relative to the player position display
            if (!direct && player.cpos) {
                x = player.pos.x + (x - player.cpos.x)
                y = player.pos.y + (y - player.cpos.y)
            }
            fn(x, y)
            onClickTarget = null
            shutdownKeyboardLook()
            player.firing = "no"
        }
    }
}

function moveToDest(cx, cy, reachCallback) {
    descriptions = []
    warnings = []
    
    if (player.cpos) {
        var x = player.pos.x + (cx - player.cpos.x)
        var y = player.pos.y + (cy - player.cpos.y)
        
        destinationMovement = [x, y]
        destinationPath = astarTraverse({attrs: playerAttrs}, {x: player.pos.x, y: player.pos.y}, {x: x, y: y})
        
        onReachCallback = reachCallback
        tryMoveTowardsDestination()
    }
}

function clickCell(x, y) {
    lastClick = [x, y]
    if (showingInventory) {
    } else if (gameStarted) {
        if ((typeof(onClickTarget) != "undefined")&&(onClickTarget != null)) {
            onClickTarget(x, y)
        } else if (gameStarted && (x < displaySizeX)) {
            if (actionMenuShown) {
                //actionMenuShown = false
            } else {
                var tx = player.pos.x + (x - player.cpos.x)
                var ty = player.pos.y + (y - player.cpos.y)
                
                if ((ty >= 0) && (ty < level.length)) {
                    var row = level[ty]
                    
                    if ((tx >= 0) && (tx < row.length)) {
                        var tile = row[tx]
                        var actions = []
                        
                        console.log(tile)
                        
                        if ("character" in tile) {
                            // TODO Check if the character is friend or foe
                            var dx = Math.abs(player.cpos.x - x)
                            var dy = Math.abs(player.cpos.y - y)
                            var meleeDistance = (dx <= 1) && (dy <= 1)

                            if ((dx == 0) && (dy == 0)) {
                                // The player itself
                                actions.push({"text": "Show inventory", "pos": {x: x, y: y}})
                                
                                actions.push({"text": "Wait", "pos": {x: x, y: y}})
                                
                                if (currentWeapon.ranged && (currentWeapon.ammo < currentWeapon.ammoMax)) {
                                    actions.push({"text": "Reload", "pos": {x: x, y: y}})
                                }
                                
                                if (currentWeapon.ranged && currentWeapon.alternate && (currentWeapon.alternate.ammo < currentWeapon.alternate.ammoMax)) {
                                    actions.push({"text": "Reload alternate", "pos": {x: x, y: y}})
                                }
                                
                                if (player.crouch  || player.prone) {
                                    actions.push({"text": "Stand", "pos": {x: x, y: y}})
                                }
                                
                                if (!player.crouch) {
                                    actions.push({"text": "Crouch", "pos": {x: x, y: y}})
                                }
                                
                                if (!player.prone) {
                                    actions.push({"text": "Prone", "pos": {x: x, y: y}})
                                }
                                
                                if (canCheat) {
                                    actions.push({"text": "God mode", "bg": {true: [64, 64, 192], false: [0, 0, 192]}})
                                }
                                
                            } else {
                                if (meleeDistance) {
                                    actions.push({"text": "Attack (melee)", "pos": {x: x, y: y}})
                                    
                                    if (!currentWeapon.ranged && currentWeapon.alternate) {
                                        actions.push({"text": "Attack (melee, alternate)", "pos": {x: x, y: y}})
                                    }
                                }
                                
                                if (currentWeapon.ranged) {
                                    actions.push({"text": "Attack (ranged)", "pos": {x: x, y: y}})
                                }
                                
                                if (currentWeapon.ranged && currentWeapon.alternate) {
                                    actions.push({"text": "Attack (ranged, alternate)", "pos": {x: x, y: y}})
                                }
                                
                                if (canCheat) {
                                    actions.push({"text": "Inspect FSM", "pos": {x: x, y: y}, "bg": {true: [64, 64, 192], false: [0, 0, 192]}})
                                }
                            }
                        }
                        
                        if ("item" in tile) {
                            actions.push({"text": "Walk here", "pos": {x: x, y: y}})
                            actions.push({"text": "Grab", "pos": {x: x, y: y}})
                        }
                        
                        if (tile.tile in tilePixActions) {
                            actions.push({"text": "Walk here", "pos": {x: x, y: y}})
                            actions.push({"text": tilePixActions[tile.tile], "pos": {x: x, y: y}})
                        }
                        
                        if (actions.length > 0) {
                            actions.push({"text": "Close", "bg": {true: [192, 64, 64], false: [48, 0, 0]}})
                            actionMenuShown = true
                            actionMenuActions = actions
                            actionMenuCenter = [x, y]
                        } else {
                            moveToDest(x, y)
                        }
                    }
                }
            }
        }
    }
}

function moveCell(x, y) {
    lastMove = [x, y]

    if (("pos" in player) && ("cpos" in player)) {
        var x = player.pos.x + (x - player.cpos.x)
        var y = player.pos.y + (y - player.cpos.y)
        
        describe(x, y)
    }
}

function updateWeapon(w) {
    if (typeof(w) != "undefined") {
        currentWeapon = w
     }
}

function randomColorBetween(c0, c1) {
    var a = Math.random()
    var a1 = 1 - a
    
    c0 = hexToColor(c0)
    c1 = hexToColor(c1)
    
    var r0 = ((c0 & 0x00FF0000) >> 16) & 0xFF
    var g0 = ((c0 & 0x0000FF00) >> 8) & 0xFF
    var b0 = ((c0 & 0x000000FF)) & 0xFF
    
    var r1 = ((c1 & 0x00FF0000) >> 16) & 0xFF
    var g1 = ((c1 & 0x0000FF00) >> 8) & 0xFF
    var b1 = ((c1 & 0x000000FF)) & 0xFF
    
    return [
        Math.floor(a * r0 + a1 * r1),
        Math.floor(a * g0 + a1 * g1),
        Math.floor(a * b0 + a1 * b1),
    ]
}

function spawnTrail(tr, x, y) {
    if (tr) {
        var cell = level[y][x]
        var num = 1 + Math.random() * tr.num
        var part = {}
        
        for (var i=0; i < num; i++) {
            part.route = TraceLine(x, y, 
                Math.round(x + (Math.random() * tr.spread[0]) - tr.spread[0]/2),
                Math.round(y + (Math.random() * tr.spread[1]) - tr.spread[1]/2)).reverse()
            part.routeStart = Date.now() + tr.delay * Math.random()
            part.timeGranule = (tr.ttl * Math.random()) / (part.route.length + 1)
            part.bg = randomColorBetween(tr.from, tr.to)
            part.fg = [0,0,0]
            part.pix = 0
            part.cssClass = ''
            part.trail = false
            
            cell.particles.push(part)
        }
    }
}

function updateDisplay() {
    if (gameStarted) {
        updateDisplayGameStarted()
    } else if (currentMenu == 0) {
        updateDisplayMenu()
    } else if (currentMenu == 1) {
        // Char select
        updateCharMenu()
    } else if (currentMenu == 2) {
        // Options
        updateOptionsMenu()
    } else if (currentMenu == 3) {
        // Contact
        //updateFundraiserMenu()
        updateContactMenu()
    } else if (currentMenu == 4) {
        // Tutorial
        updateTutorial()
    } else if (currentMenu == 5) {
        // Tutorial
        updateKeybindings()
    }
    
    terminal.setPixelBg(lastMove[0], lastMove[1], 
        [Math.round(((Date.now() / 200.0) % 1 - 0.5) * 128 + 128),
         Math.round(((Date.now() / 400.0) % 1 - 0.5) * 128 + 32), 
         Math.round(((Date.now() / 100.0) % 1 - 0.5) * 32 + 64)])
}

function aberrateColor(col) {
    if (Math.random() < 0.3) {
        return [
            col[0] + Math.floor(Math.random() * 64),
            col[1] + Math.floor(Math.random() * 64),
            col[2] + Math.floor(Math.random() * 64)
        ]
    } else {
        return col
    }
}

function drawBox(x, y, w, h, col) {
    var y0 = Math.max(y, 0)
    var x0 = Math.max(x, 0)
    
    var y1 = Math.min(y + h, displaySizeY)
    var x1 = Math.min(x + w, displaySizeX)
    
    for (var j=y0; j < y1; j++) {
        for (var i=x0; i < x1; i++) {
            terminal.setPixel(i, j, 0, col, col)
        }
    }
}

function drawBoxAlpha(x, y, w, h, col, a) {
    var y0 = Math.max(y, 0)
    var x0 = Math.max(x, 0)
    
    var y1 = Math.min(y + h, displaySizeY)
    var x1 = Math.min(x + w, displaySizeX)
    
    for (var j=y0; j < y1; j++) {
        for (var i=x0; i < x1; i++) {
            var cl = mixRGB(terminal.getPixelBg(i, j), col, a)
            terminal.setPixel(i, j, 0, cl, cl)
        }
    }
}

function drawButtonWithText(x, y, txt, width, fg, bg, menuOp) {
    var vpadtxt = Array(width + 1).join(" ")
    var dw = width - txt.length
    var lpad = Math.ceil(dw / 2) + 1
    var rpad = Math.floor(dw / 2) + 1
    
    var luma = (menuSel == menuOp)?[255,255,255]:[0,0,0]
    
    var moveWithinBounds = (lastMove[0] >= x)&&(lastMove[0] <= (x + width))&&(lastMove[1] >= y)&&(lastMove[1] < (y + 3))
    
    if (!Array.isArray(fg)) {
        fg = fg[moveWithinBounds]
    }
    
    if (!Array.isArray(bg)) {
        bg = bg[moveWithinBounds]
    }
    
    drawAsciiText(x, y, vpadtxt, fg, bg, luma)
    drawAsciiText(x, y + 1, Array(lpad).join(" ") + txt + Array(rpad).join(" "), fg, bg, luma)
    drawAsciiText(x, y + 2, vpadtxt, fg, bg, luma)
    
    if ((lastClick[0] >= x)&&(lastClick[0] <= (x + width))&&
        (lastClick[1] >= y)&&(lastClick[1] < (y + 3))) {
        return true
    } else {
        if (moveWithinBounds) {
            if ((menuSel != menuOp)&&(editMode)) {
                finishEditText()
            }
            menuSel = menuOp
        }
        return false
    }
}

function drawEditWithHint(x, y, txt, hint, width, fg, bg, menuOp) {
    var vpadtxt = Array(width + 1).join(" ")
    
    if (!txt || txt.length == 0) {
        txt = hint
    }
    
    var dw = width - txt.length
    var lpad = Math.max(1, Math.ceil(dw / 2) + 1)
    var rpad = Math.max(1, Math.floor(dw / 2) + 1)
    
    drawAsciiText(x, y, vpadtxt, fg, bg)
    drawAsciiText(x, y + 1, Array(lpad).join(" ") + txt + Array(rpad).join(" "), fg, bg)
    drawAsciiText(x, y + 2, vpadtxt, fg, bg)
    
    if ((lastClick[0] >= x)&&(lastClick[0] <= (x + width))&&
        (lastClick[1] >= y)&&(lastClick[1] < (y + 3))) {
        return true
    } else {
        if ((lastMove[0] >= x)&&(lastMove[0] <= (x + width))&&
            (lastMove[1] >= y)&&(lastMove[1] < (y + 3))) {
            if ((menuSel != menuOp)&&(editMode)) {
                finishEditText()
            }
            menuSel = menuOp
        }
        return false
    }
}

var editMode = false
var editModeSingleLine = true
var editCallback
var editText
var editCursorPos
var cursorBlinkInterval
function beginEditText(txt, cb) {
    editMode = true
    if (txt) {
        editText = txt
        editCursorPos = txt.length
    } else {
        editText = ""
        editCursorPos = 0
    }
    
    var nb = 0
    cursorBlinkInterval = setInterval(function() {
        if (editText.length > 0) {
            if ((nb % 3) == 0) {
                cb(editText.slice(0, editCursorPos-1) + '_' + editText.slice(editCursorPos))
            } else {
                cb(editText)
            }
        }
        
        nb += 1
    }, 200)
    
    editCallback = function(key) {
        var finished = false
        if (key == 8) {
            if (editCursorPos >= editText.length) {
                editText = editText.slice(0, editText.length - 1)
            } else {
                editText = editText.slice(0, editCursorPos-1) + editText.slice(editCursorPos)
            }
            editCursorPos -= 1
        } else if (key == 37) {
            editCursorPos = Math.max(0, editCursorPos-1)
        } else if (key == 39) {
            editCursorPos = Math.min(editText.length, editCursorPos+1)
        } else if (key == 13) {
            finishEditText()
            finished = true
        } else {
            if (editCursorPos >= editText.length) {
                editText += String.fromCharCode(key)
            } else {
                editText = editText.slice(0, editCursorPos-2) + String.fromCharCode(key) + editText.slice(editCursorPos-1)
            }
            editCursorPos += 1
        }
        
        cb(editText, finished)
    }
}

function finishEditText() {
    clearInterval(cursorBlinkInterval)
    if (typeof(editCallback) !== "undefined") {
        editCallback(39)
    }
    editMode = false
}

function drawButtonWithCheckAndText(x, y, txt, width, checked, fg, bg, menuOp) {
    var vpadtxt = Array(width + 1).join(" ")
    var dw = width - txt.length
    var lpad = Math.ceil(dw / 2) + 1
    var rpad = Math.floor(dw / 2) + 1
    drawAsciiText(x, y, vpadtxt, fg, bg)
    drawAsciiText(x, y + 1, Array(lpad).join(" ") + txt + Array(rpad).join(" "), fg, bg)
    
    terminal.setPixel(x + 1, y + 1, checked?254:255, fg, bg)
    
    drawAsciiText(x, y + 2, vpadtxt, fg, bg)
    
    if ((lastClick[0] >= x)&&(lastClick[0] <= (x + width))&&
        (lastClick[1] >= y)&&(lastClick[1] < (y + 3))) {
        return true
    } else {
        if ((lastMove[0] >= x)&&(lastMove[0] <= (x + width))&&
            (lastMove[1] >= y)&&(lastMove[1] < (y + 3))) {
            if ((menuSel != menuOp)&&(editMode)) {
                finishEditText()
            }
            menuSel = menuOp
        }
        
        return false
    }
}

function drawStarsAndGanymede() {
    if (menuStars.length == 0) {
        var cols = [[140, 140, 140], [120, 120, 120], [70, 70, 70], [32, 32, 32]]
        var pixis = [46, 7, 42, 15, 21, 233]
        for (var i=0; i < 100; i++) {
            var p = Math.floor(Math.random() * 4) + 1
            var rpix = Math.random() * p/3
            menuStars.push({
                dv: p,
                col: aberrateColor(cols[p-1]),
                y: Math.floor(Math.random() * displaySizeY),
                pix: pixis[Math.floor(rpix * rpix * pixis.length)],
                phase: Math.random()
            })
        }
    }
    
    var d = Date.now()
    
    for (var i=0; i < menuStars.length; i++) {
        var star = menuStars[i]
        var tg = ((d / (32000.0 * star.dv) + star.phase) % 1)
        var px = Math.floor(tg * (displaySizeX + 64) - 32)
        var py = Math.floor( -tg * 8 + star.y - 4)
        terminal.setPixel(px, py, star.pix, star.col, undefined, [255, 255, 255])
    }
    
    if (ganymedeSprite) {
        var tg = ((d / 24000.0) % 1)
        var px = Math.floor( tg * (displaySizeX + 64) - 32)
        var py = Math.floor( -tg * (displaySizeY / 2) + displaySizeY / 4 * 2)
        drawRexSprite(Math.min(displaySizeX, px), py, ganymedeSprite)
    }
}

function updateDisplayMenu() {
    terminal.clear()
    
    drawStarsAndGanymede()
    
    if (titleSprite) {
        //drawRexSprite(Math.floor((displaySizeX + 32)/2) - 20, 0, titleSprite)
        drawRexSpriteHCenter(titleSprite, 0)
    }
        
    if (tutorialSeen) {
        if (drawButtonWithText((displaySizeX - 12)/2, 21, "Start", 12, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
            menuUse(0)
        }
    } else {
        if (drawButtonWithText((displaySizeX - 12)/2, 21, "Tutorial", 12, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
            menuUse(0)
        }
    }
    
    if (drawButtonWithText((displaySizeX - 12)/2, 25, "Options", 12, opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }
    
    if (drawButtonWithText((displaySizeX - 12)/2, 29, "Contact", 12, opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
    
    if (tutorialSeen) {
        if (drawButtonWithText((displaySizeX - 12)/2, 33, "Tutorial", 12, opsColsFg[menuSel == 3], opsColsBg[menuSel == 3], 3)) {
            menuUse(3)
        }
    } else {
        if (drawButtonWithText((displaySizeX - 12)/2, 33, "Start", 12, opsColsFg[menuSel == 3], opsColsBg[menuSel == 3], 3)) {
            menuUse(3)
        }
    }
    
    if (typeof(require) !== "undefined") {
        var exbg = {true: [192, 64, 64], false: [48, 0, 0]}
        var exfg = {true: [192, 192, 64], false: [48, 48, 0]}
        if (drawButtonWithText((displaySizeX - 12)/2, 38, "Exit Game", 12, exfg[menuSel == 4], exbg[menuSel == 4], 4)) {
            menuUse(4)
        }
    }
    
   
    /*for (var i=0; i < 256; i++) {
        terminal.setPixel(i % 16, Math.floor(i / 16), i, [255, 255, 255], [0, 0, 0])
    }*/
    
    drawAsciiText(0, displaySizeY-1, "Developed by ViciousRobotRodent.com - @johnvillarz - 2015", [128, 128, 128])
}

var charSprites = {}
var perkColors = {
    "Adrenaline": [255, 0, 0],
    "Passive": [0, 255, 0],
    "Active": [0, 0, 255],
    "FullAdrenaline": [64, 64, 128]
}
function updateCharMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    drawAsciiText(1, 1, "Pick your class", [192, 255, 192])

    drawBoxAlpha(17, 3, 76, 36, [0, 0, 0], UI_ALPHA)
    for (var i=0; i < playerClasses.length; i++) {
        var selected = menuSel == i
        var name = playerClasses[i].name
        var id = playerClasses[i].id
        var description = playerClasses[i].description
        
        if (drawButtonWithText(1, 3 + i * 3, name, 16, opsColsFg[selected], opsColsBg[selected], i)) {
            if (menuSel == i) {
                menuUse(i)
            } else {
                menuSel = i
                lastClick = [-1, -1]
            }
        }
        
        if (selected) {
            if (id in charSprites) {
                if (charSprites[id] != null) {
                    drawRexSprite(18, 3, charSprites[id])
                }
            } else {
                charSprites[id] = null
                
                var f = function(sid) {
                    loadXpSprite("char" + sid, function(sp) { charSprites[sid] = sp })
                }
                f(id)
            }
            
            var statX = 40
            var statY = 3
            var attrTxtFG = [255, 255, 64]
            var attrTxtBG = [0, 0, 0]
            
            drawAsciiText(statX, statY, "Health", [64, 255, 64], [0, 0, 0])
            drawAsciiText(statX + 10, statY, charAttrs[id].HP.starting + "/" + charAttrs[id].HP.max, attrTxtFG, attrTxtBG)
            drawConsoleBar(statX + 22, statY, 30, 1, charAttrs[id].HP.max/200)
            statY += 2
            
            drawAsciiText(statX, statY, "Armor", [64, 255, 64], [0, 0, 0])
            drawAsciiText(statX + 10, statY, charAttrs[id].AR.starting + "/" + charAttrs[id].AR.max, attrTxtFG, attrTxtBG)
            drawConsoleBar(statX + 22, statY, 30, 1, charAttrs[id].AR.max/200)
            statY += 2
            
            drawAsciiText(statX, statY, "Strength", [64, 255, 64], [0, 0, 0])
            drawAsciiText(statX + 10, statY, charAttrs[id].ST.starting + "/" + charAttrs[id].ST.max, attrTxtFG, attrTxtBG)
            drawConsoleBar(statX + 22, statY, 30, 1, charAttrs[id].ST.max/200)
            statY += 2
            
            drawAsciiText(statX, statY, "Precision", [64, 255, 64], [0, 0, 0])
            drawAsciiText(statX + 10, statY, charAttrs[id].PR.starting + "/" + charAttrs[id].PR.max, attrTxtFG, attrTxtBG)
            drawConsoleBar(statX + 22, statY, 30, 1, charAttrs[id].PR.max/200)
            statY += 2
            
            drawAsciiText(statX, statY, "Speed", [64, 255, 64], [0, 0, 0])
            drawAsciiText(statX + 10, statY, charAttrs[id].SP.starting + "/" + charAttrs[id].SP.max, attrTxtFG, attrTxtBG)
            drawConsoleBar(statX + 22, statY, 30, 1, charAttrs[id].SP.max/200)
            statY += 2
            
            drawAsciiText(statX, statY, "Weapon", [64, 255, 64], [0, 0, 0])
            drawAsciiText(statX + 10, statY, charAttrs[id].Weapon, attrTxtFG, attrTxtBG)
            statY += 2
            
            drawAsciiText(statX, statY, "Special perks", [64, 255, 64], [0, 0, 0])
            statY += 2
            
            for (var prk=0; prk < charAttrs[id].perks.length; prk++) {
                var color = [128, 128, 128]
                
                for (var x=0; x < charAttrs[id].perks[prk].attr.length; x++) {
                    var prkAttr = charAttrs[id].perks[prk].attr[x]
                    
                    color = sumRGB(perkColors[prkAttr], color)
                }
                
                drawAsciiText(statX + 2, statY, charAttrs[id].perks[prk].txt, color, attrTxtBG)
                statY += 2
            }
            
            //drawAsciiText(18, 27, description, [224, 244, 244], [0,0,0], [0,0,0])
            
            drawBoxedAsciiText(18, 27, 75, 20, description, [224, 244, 244], [0,0,0], [0,0,0], 2)
        }
    }
    
    drawBoxAlpha(1, 40, 34, 13, [0, 0, 0], UI_ALPHA)
    drawAsciiText(2, 41, "Perk color legend:", [0, 255, 0], [0,0,0], [0,0,0])
    drawAsciiText(4, 43, "Adrenaline based, passive perk", sumRGB(sumRGB([128, 128, 128], perkColors["Adrenaline"]), perkColors["Passive"]), [0,0,0], [0,0,0])
    drawAsciiText(4, 45, "Adrenaline based, active perk", sumRGB(sumRGB([128, 128, 128], perkColors["Adrenaline"]), perkColors["Active"]), [0,0,0], [0,0,0])
    drawAsciiText(4, 47, "Full Adrenaline, active perk", sumRGB(sumRGB([128, 128, 128], perkColors["FullAdrenaline"]), perkColors["Active"]), [0,0,0], [0,0,0])
    drawAsciiText(4, 49, "Passive perk", sumRGB([128, 128, 128], perkColors["Passive"]), [0,0,0], [0,0,0])
    drawAsciiText(4, 51, "Active perk", sumRGB([128, 128, 128], perkColors["Active"]), [0,0,0], [0,0,0])
    
    if (drawEditWithHint(((displaySizeX - 32)/2), displaySizeY - 10, ownUsername, "Player's name", 32, opsColsFg[menuSel == playerClasses.length], opsColsBg[menuSel == playerClasses.length], playerClasses.length)) {
        menuUse(playerClasses.length)
    }
    
    if (drawButtonWithText(((displaySizeX - 32)/2), displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == playerClasses.length+1], opsColsBg[menuSel == playerClasses.length+1], playerClasses.length+1)) {
        menuUse(playerClasses.length+1)
    }
}

function updateOptionsMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    if (drawButtonWithCheckAndText(((displaySizeX - 32)/2), 21, "Duplicate console size", 32, localStorage.dupConSz == "true", opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
    
    if (drawButtonWithCheckAndText(((displaySizeX - 32)/2), 25, "Use 2xSAI shader", 32, localStorage.use2xsai == "true", opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }
    
    if (drawButtonWithCheckAndText(((displaySizeX - 32)/2), 29, "Use Music", 32, localStorage.useMusic == "true", opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
    
    if (drawButtonWithCheckAndText(((displaySizeX +-32)/2), 33, "Use Sound", 32, localStorage.useSound == "true", opsColsFg[menuSel == 3], opsColsBg[menuSel == 3], 3)) {
        menuUse(3)
    }
    
    if (drawButtonWithText(((displaySizeX - 32)/2), 37, "Keybindings", 32, opsColsFg[menuSel == 4], opsColsBg[menuSel == 4], 4)) {
        menuUse(4)
    }
    
    if (drawButtonWithText(((displaySizeX - 32)/2), displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 5], opsColsBg[menuSel == 5], 5)) {
        menuUse(5)
    }
    
}

function randInt(a, b) {
    if (b) {
        return Math.floor(Math.random() * (b-a) + a)
    } else {
        return Math.floor(Math.random() * a)
    }
}

function updateFundraiserMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    if (lighthouseSprite) {
        drawRexSprite(6, 6, lighthouseSprite)
    }
    
    drawAsciiText(20, 8, "Fundraiser driven with", [128, 128, 128])
    drawAsciiText(20, 10, "Light", [190, 233, 255])
    drawAsciiText(25, 10, "house", [255, 255, 255])
    drawAsciiText(20, 12, "Raise money with Bitcoin", [128, 128, 128])
    
    drawAsciiText(20, 17, "Ganymede Gate needs your help to become the best space multiplayer", [255, 255, 255])
    drawAsciiText(20, 18, "roguelike!! Development is chugging along nicely, but there's some", [255, 255, 255])
    drawAsciiText(20, 19, "assets that need to be secured to make this project successful. So", [255, 255, 255])
    drawAsciiText(20, 20, "this fundraiser has been started with that goal in mind.", [255, 255, 255])
    drawAsciiText(20, 22, "Some of the most needed things at the moment are:", [255, 255, 255])
    drawAsciiText(20, 24, " * Domain with dedicated server", [255, 255, 255])
    drawAsciiText(20, 25, " * Reddit ads to attract new players", [255, 255, 255])
    drawAsciiText(20, 26, " * Lobby system for distributed servers around the globe", [255, 255, 255])
    drawAsciiText(20, 27, " * More art: Music, sprites, etc.", [255, 255, 255])
    
    drawAsciiText(20, 35, "Each donation counts!", [randInt(128, 255), randInt(128, 255), randInt(128, 255)])
    drawAsciiText(20, 37, "Download Lighthouse for your platform, install and then download", [255, 255, 255])
    drawAsciiText(20, 38, "the project to pledge and track progress.", [255, 255, 255])
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 14, "Download Lighthouse", 32, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 10, "Download project", 32, opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
}

function updateContactMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    if (titleSprite) {
        drawRexSpriteHCenter(titleSprite, 0)
    }
    
    drawAsciiText(10, 25, "Made with ", [200, 200, 200], [0, 0, 0])
    drawAsciiText(20, 25, "\u2665 ", [225 + Math.cos(Date.now() / 100.0) * 30, 68, 126 + Math.sin(Date.now() / 200.0) * 60], [0, 0, 0])
    drawAsciiText(22, 25, "@ CCS/VE using Node.js, HTML5, WebGL and NW.js 100% Open Source", [200, 200, 200], [0, 0, 0])
    drawAsciiText(22, 26, "Licensed under the MIT License / Assets CC-BY 4.0", [200, 200, 200], [0, 0, 0])
    
    if (gplusSprite) {
        if (drawRexSpriteHCenter(gplusSprite, 40, -24)) {
            // Open G+
            OpenInNewTab("https://plus.google.com/+JohnVillar")
        }
        drawAsciiText((displaySizeX/2) - 24 - 6, 51, "+JohnVillar", [200, 200, 200], [0, 0, 0])
    }
    
    if (twitterSprite) {
        if (drawRexSpriteHCenter(twitterSprite, 40)) {
            // Open Twitter
            OpenInNewTab("https://twitter.com/johnvillarz")
        }
        drawAsciiText(((displaySizeX - 12)/2), 51, "@johnvillarz", [200, 200, 200], [0, 0, 0])
    }
    
    if (redditSprite) {
        if (drawRexSpriteHCenter(redditSprite, 40, 24)) {
            // Open Reddit
            OpenInNewTab("https://www.reddit.com/r/GanymedeGate/")
        }
        drawAsciiText((displaySizeX/2) + 24 - 8, 51, "/r/GanymedeGate", [200, 200, 200], [0, 0, 0])
    }
    
    if (drawButtonWithText(((displaySizeX - 32)/2), displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
}

var TUTORIAL_VERSION = 2
function updateTutorial() {
    terminal.clear()
    var sinusoidal = Math.floor(Math.sin(Date.now()/100.0) * 32 + 32) + 48
    
    drawAsciiText(35, 20, "There should be some tut here, ain't it? \u263A", [255, 200, 200], [0, 0, 0])
    drawAsciiText(10, 23, "You can remap keys in the options menu", [255, 255, 200], [0, 0, 0])
    drawAsciiText(10, 25, "You can use WASD/Vikeys/Arrows to move (diagonals too)", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 27, "F fires, Shift+F uses alternate fire", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 29, "G grabs stuff from the floor", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 31, "R reloads weapons, Shift+R reloads alternate ammo", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 33, "T, will eventually, activate the active super power", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 35, "V toggles look mode", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 37, "Space activates levers and exits level", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 39, "Space also shows the action menu over stuff in look mode", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 41, "You can also use the mouse", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 43, "Shift+Direction lets you jump/trample (have fun with Melee and Swordmaster classes)", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 45, "X, '.' or Keypad 5 skips one turn", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 47, "? shows all hud and last messages", [200, 200, 200], [sinusoidal, sinusoidal, 0])
    
    var bgcol = [0, sinusoidal, 0]
    drawAsciiText(18, 23, "remap keys", [255, 128, 128], [Math.floor(Math.sin(Date.now()/100.0) * 32 + 32) + 48, 0, 0])
    drawAsciiText(22, 25, "WASD/Vikeys/Arrows", [128, 255, 128], bgcol)
    drawAsciiText(10, 27, "F", [128, 255, 128], bgcol)
    drawAsciiText(19, 27, "Shift+F", [128, 255, 128], bgcol)
    drawAsciiText(10, 29, "G", [128, 255, 128], bgcol)
    drawAsciiText(10, 31, "R", [128, 255, 128], bgcol)
    drawAsciiText(29, 31, "Shift+R", [128, 255, 128], bgcol)
    drawAsciiText(10, 33, "T", [128, 255, 128], bgcol)
    drawAsciiText(10, 35, "V", [128, 255, 128], bgcol)
    drawAsciiText(10, 37, "Space", [128, 255, 128], bgcol)
    drawAsciiText(10, 39, "Space", [128, 255, 128], bgcol)
    drawAsciiText(10, 43, "Shift+Direction", [128, 255, 128], bgcol)
    drawAsciiText(10, 45, "X, '.' or Keypad 5", [128, 255, 128], bgcol)
    drawAsciiText(10, 47, "?", [128, 255, 128], bgcol)
    
    
    /*if (drawButtonWithText(((displaySizeX + 32)/2) - 18, displaySizeY - 10, "<< Previous", 16, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) + 2, displaySizeY - 10, "Next >>", 16, opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }*/
    
    if (drawButtonWithText(((displaySizeX - 32)/2), displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
}

function saveKeyBindings() {
    localStorage.setItem("keyBindings", JSON.stringify(keyBindingNames))
}

function loadKeyBindings() {
    try {
        var newKeyBindings = localStorage.getItem("keyBindings")
        
        if ((typeof(newKeyBindings) !== "undefined") && (newKeyBindings != null)) {
            var parsedKeyBindingNames = JSON.parse(newKeyBindings)
            
            if ((typeof(parsedKeyBindingNames) !== "undefined") && (parsedKeyBindingNames != null)) {
                keyBindingNames = parsedKeyBindingNames
            }
        }
    } catch (e) {
        // Nothing, no keybindings then
    }
}

function updateKeybindings() {
    terminal.clear()
    
    drawStarsAndGanymede()
    
    var w4 = displaySizeX / 4
    var y = 6
    
    drawAsciiText(22, 3, "Keybindings (Use \u2191 and \u2193 to move between options)", [240, 240, 240], [0, 0, 0])
    
    var btnFn = function(num, key) {
        var name = keybindingsMenuIdentifier[num]
        var key = keyBindingNames[num]
        if (!key || (key.length <= 0)) {
            key = "Not set"
        }
        
        var py = y + Math.floor(num / 2) * 2
        var px = Math.floor(w4 * (2 * (num % 2)) + w4/2)
        
        var fgBtCol = opsColsFg[menuSel == num]
        var bgBtCol = opsColsBg[menuSel == num]
        
        if (inspectKeyboardIndex >= 0) {
            if (inspectKeyboardIndex == num) {
                fgBtCol = [255, 255, 200]
                bgBtCol = [200, 100, 100]
            } else {
                fgBtCol = opsColsFg[false]
                bgBtCol = opsColsBg[false]
            }
        }
        
        drawAsciiText(px - Math.floor(name.length/2), py+1, name, [200, 200, 200], [0, 0, 0])
        if (drawButtonWithText(px + w4 - 8, py, key, 16, fgBtCol, bgBtCol, num)) {
            inspectKeyboardCodes = true
            inspectKeyboardIndex = num
            inspectKeyboardIdentifier = name
        }
    }
    
    btnFn(0)
    btnFn(1)
    y += 4
    btnFn(2)
    btnFn(3)
    y += 4
    btnFn(4)
    btnFn(5)
    y += 4
    btnFn(6)
    btnFn(7)
    y += 4
    btnFn(8)
    btnFn(9)
    y += 4
    btnFn(10)
    btnFn(11)
    y += 4
    btnFn(12)
    btnFn(13)
    y += 4
    btnFn(14)
    btnFn(15)
    y += 4
    btnFn(16)
    btnFn(17)
    
    if (drawButtonWithText((displaySizeX/2) - 34, displaySizeY - 4, "Save changes", 32, 
        opsColsFg[menuSel == (itemsPerMenu[currentMenu]-2)], opsColsBg[menuSel == (itemsPerMenu[currentMenu]-2)], (itemsPerMenu[currentMenu]-2))) {
        menuUse((itemsPerMenu[currentMenu]-2))
    }
    
    if (drawButtonWithText((displaySizeX/2) + 2, displaySizeY - 4, "Go back", 32, 
        opsColsFg[menuSel == (itemsPerMenu[currentMenu]-1)], opsColsBg[menuSel == (itemsPerMenu[currentMenu]-1)], (itemsPerMenu[currentMenu]-1))) {
        menuUse((itemsPerMenu[currentMenu]-1))
    }
}

var mouseActions = {
    "Walk here": function(x, y, data) {
        moveToDest(x, y)
    },
    "Wait": function(x, y, data) {
        pos(0, 0, false)
    },
    "Grab": function(x, y, data) {
        moveToDest(x, y, function() {
            grab() 
        })
    },
    "Attack (melee)": function(x, y, data) {
        moveToDest(x, y)
    },
    "Attack (melee, alternate)": function(x, y, data) {
        // Correct x and y relative to the player position display
        x = player.pos.x + (x - player.cpos.x)
        y = player.pos.y + (y - player.cpos.y)

        fire(true, {x: x, y: y})
    },
    "Attack (ranged)": function(x, y, data) {
        // Correct x and y relative to the player position display
        x = player.pos.x + (x - player.cpos.x)
        y = player.pos.y + (y - player.cpos.y)

        fire(false, {x: x, y: y})
    },
    "Attack (ranged, alternate)": function(x, y, data) {
        // Correct x and y relative to the player position display
        x = player.pos.x + (x - player.cpos.x)
        y = player.pos.y + (y - player.cpos.y)

        fire(true, {x: x, y: y})
    },
    "Activate": function(x, y, data) {
        moveToDest(x, y, function() {
            use()
        })
    },
    "Open door": function(x, y, data) {
        moveToDest(x, y, function() {
            // Nothing to do
        })
    },
    "Close door": function(x, y, data) {
        // TODO Fix this one
        moveToDest(x, y, function() {
        })
    },
    "Exit level": function(x, y, data) {
        moveToDest(x, y, function() {
            use()
        })
    },
    "Show inventory": function(x, y, data) {
        toggleInventory()
    },
    "Reload": function(x, y, data) {
        reload(false)
    },
    "Reload alternate": function(x, y, data) {
        reload(true)
    },
    "Stand": function(x, y, data) {
        if (player.crouch) {
            crouch()
        } else if (player.prone) {
            prone()
        }
    },
    "Crouch": function(x, y, data) {
        crouch()
    },
    "Prone": function(x, y, data) {
        prone()
    },
    "Use": function() { // Inventory action
        useInventory(inventoryIndex)
    },
    "Drop": function() { // Inventory action
        drop(inventoryIndex)
    },
    "Unload": function() { // Inventory action
        unload(inventoryIndex)
    },
    "Inspect": function() { // Inventory action
        inspect(inventoryIndex)
    },
    "Shortcut": function() { // Inventory action
        askShortcut(inventoryIndex)
    },
    "God mode": function() {
        cheat('god')
    },
    "Inspect FSM": function(x, y, data) {
        var nonce = Math.round(Math.random() * 0x1FFFFFFF)
        cheat('showfsm', {x: x, y: y, id: nonce})
    }
}

function updateDisplayGameStarted() {
    var sx0 = Math.min(Math.max(player.pos.x - displaySizeX/2, 0), level[0].length - displaySizeX)
    var sy0 = Math.min(Math.max(player.pos.y - displaySizeY/2, 0), level.length - displaySizeY)
    
    minCoords.x = sx0
    minCoords.y = sy0
    
    terminal.clear()

    if (showingInventory) {
        descriptions = []
        warnings = []
        drawInventory()
    } else {
        for (var y=0; y < displaySizeY; y++) {
            var levelRow = level[sy0 + y]
            for (var x=0; x < displaySizeX; x++) {
                var tile = levelRow[sx0 + x]
                var shroud = false
                var fg = hexToRGBArr("#AAAAAA")
                var bg = undefined
                var luma = undefined
                var glyph = asciiMapping[" "]
                
                if (tile.turn) {
                    if (tile.turn != turn) {
                        shroud = true
                    }
                }
                
                
                var cssClass = undefined
                if (tile.particles.length > 0) {
                    var ti = 0
                    
                    while (ti < tile.particles.length) {
                        var part = tile.particles[ti]
                        glyph = part.pix
                        cssClass = part.cssClass
                        fg = part.fg || undefined
                        bg = part.bg || undefined
                        
                        var ct = Date.now()
                        
                        if ((ct - part.routeStart) >= part.timeGranule) {
                            if (part.trail) {
                                spawnTrail(part.trail, sx0+x, sy0+y)
                            }
                            
                            tile.particles.splice(ti, 1)
                            part.routeStart = ct
                            var pos = part.route.pop()
                            if (pos) {
                                if ((pos[1] >= 0)&&(pos[1] < level.length)&&
                                    (pos[0] >= 0)&&(pos[0] < level[0].length)) {
                                    level[pos[1]][pos[0]].particles.push(part)
                                }
                            }
                        } else {
                            ti++
                        }
                    }
                } else {
                    var fgAssigned = false
                    var hazardBackground = false
                    
                    if (tile.character) {
                        fgAssigned = true
                        if ((player.pos.x == x + sx0)&&(player.pos.y == y +sy0)) {
                            player.cpos = {x: x, y: y}
                        }
                        
                        glyph = tile.character.pix
                        if (tile.character.color) {
                            fg = tile.character.color
                        }
                        cssClass = tile.character.cssClass
                    } else if (tile.item) {
                        fgAssigned = true
                        glyph = tile.item.pix
                        fg = tile.item.color
                        cssClass = tile.item.cssClass
                    } else if (tile.debris) {
                        fgAssigned = true
                        glyph = tile.debris.pix
                        fg = tile.debris.color
                        cssClass = tile.debris.cssClass
                    } 
                    
                    if (tile.tile) {
                        if (!fgAssigned) {
                            glyph = tile.tile
                            
                            if (tile.fg) {
                                fg = hexToRGBArr(tile.fg)
                            } else {
                                fg = [0xAA, 0xAA, 0xAA]
                            }
                            
                            cssClass = tile.cssClass
                        }
                        
                        if (tile.bg) {
                            bg = hexToRGBArr(tile.bg)
                        } else {
                            bg = [0,0,0]
                        }
                        
                        hazardBackground = 'damage' in tile
                        if (hazardBackground) {
                            cssClass = tile.cssClass
                            //console.log("Overriding cssClass for " + tile.cssClass)
                        }
                    }
                }
                
                if (cssClass) {
                    if (cssClass in colorMap) {
                        var rule = colorMap[cssClass]
                        
                        if ((!tile.fg)&&("color" in rule)) {
                            fg = fgColorFromColorMapRule(rule, x*y)
                        }
                        
                        if ((!tile.bg)&&("backgroundColor" in rule)&&(!hazardBackground || !fgAssigned)) {
                            bg = rule.backgroundColor
                        }
                        
                        if ((!tile.luma)&&("luma" in rule)) {
                            luma = rule.luma
                        }
                    } else if (cssClass in cssRules) {
                        var rule = cssRules[cssClass]
                        
                        if ((!tile.fg)&&(rule.style.color.length > 0)) {
                            fg = rule.style.color
                        }
                        
                        if ((!tile.bg)&&(rule.style.backgroundColor.length > 0)&&(!hazardBackground || !fgAssigned)) {
                            bg = rule.style.backgroundColor
                        }
                    }
                }
                
                var lgt = tile.light
                if (shroud) {
                    fg = hsvModulate(fg, 1.0, 0.0, 0.2) //"#181818"
                    
                    if (bg) {
                        bg = hexToRGBArr("#000000")
                    }
                    
                    lgt = undefined //lgt.color = hsvModulate(lgt.color, 1.0, 0.0, 0.5)
                }
                
                if ((typeof(tile.hl) !== "undefined") && (tile.hl.t == turn)) {
                    if (typeof(tile.hl.col.color) != "undefined") {
                        var nc = fgColorFromColorMapRule(tile.hl.col, 0)
                        bg = mixRGB(bg, nc, 0.5)
                        
                        if (typeof(lgt) !== "undefined") {
                            ncol = mixRGB(lgt.color, nc, 0.5)
                        }
                        
                        lgt = {color: ncol, intensity: 0}
                    } else {
                        fg = mixRGB(fg, tile.hl.col, 0.5)
                        bg = mixRGB(bg, tile.hl.col, 0.5)
                        
                        var ncol = tile.hl.col
                        if (typeof(lgt) !== "undefined") {
                            ncol = mixRGB(lgt.color, ncol, 0.5)
                        }
                        
                        lgt = {color: ncol, intensity: 0}
                    }
                }
                
                terminal.setPixel(x, y, glyph, fg, bg, luma, lgt)
            }
        }
        
        updateAttrs()
        updateLogs()
    }

    if ((typeof(playerAttrs) != "undefined") && (playerAttrs.hp.pos <= 0)) {
        actionMenuShown = false
        
        if (player.isAlive) {
            player.isAlive = false
            lastClick = [-1, -1]
            lastMove = [-1, -1]
        }
        
        if (drawButtonWithText(((displaySizeX + 32)/2) - 24, displaySizeY - 4, "Return to Menu", 16, opsColsFg[true], opsColsBg[true], 0)) { //opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
            currentMenu = 0
            gameStarted = false
            lastClick = [-1, -1]
            lastMove = [-1, -1]
            destinationMovement = undefined
            
            level = []
            queuedAnns = []
            currentTips = []
            showingInventory = false
            announcements = []
            
            reconnect()
        }
    } else {
        player.isAlive = true
    }
    
    for (var i=0; i < descriptions.length; i++) {
        var desc = descriptions[i]
        if (desc.lines.length > 1) {
            for (var j=0; j < desc.lines.length; j++) {
                var fg = [192,192,192]
                var bg = [32,32,32]
                var luma = [0,0,0]
                var d = desc.lines[j]
                
                if ("cssClass" in d) {
                    if (d.cssClass in colorMap) {
                        var rule = colorMap[d.cssClass]
                        
                        if ((!tile.fg)&&("color" in rule)) {
                            fg = fgColorFromColorMapRule(rule, x*y)
                        }
                        
                        if ((!tile.bg)&&("backgroundColor" in rule)) {
                            bg = rule.backgroundColor
                        }
                        
                        if ((!tile.luma)&&("luma" in rule)) {
                            luma = rule.luma
                        }
                    }
                }
                
                if ("fg" in d) {
                    fg = d.fg
                }
                
                drawAsciiText(desc.pos[0], desc.pos[1] + j, d.text, fg, bg, luma)
            }
        }
    }
    
    for (var i=0; i < warnings.length; i++) {
        var warn = warnings[i]
        if (warn.lines.length >= 1) {
            for (var j=0; j < warn.lines.length; j++) {
                var fg = [192,192,192]
                var bg = [32,32,32]
                var luma = [0,0,0]
                var d = warn.lines[j]
                
                if ("cssClass" in d) {
                    if (d.cssClass in colorMap) {
                        var rule = colorMap[d.cssClass]
                        
                        if ((!tile.fg)&&("color" in rule)) {
                            fg = fgColorFromColorMapRule(rule, x*y)
                        }
                        
                        if ((!tile.bg)&&("backgroundColor" in rule)) {
                            bg = rule.backgroundColor
                        }
                        
                        if ((!tile.luma)&&("luma" in rule)) {
                            luma = rule.luma
                        }
                    }
                }
                
                if ("fg" in d) {
                    fg = d.fg
                }
                
                drawAsciiText(warn.pos[0], warn.pos[1] + j, d.text, fg, bg, luma)
            }
        }
    }
    
    for (var i=0; i < currentPkts.length; i++) {
        var pkt = currentPkts[i]
        
        var fg = [192,192,192]
        var bg = [32,32,32]
        var luma = [0,0,0]
        
        var dt = (Date.now() - pkt.initialTime)
        var txt
        var dx = 0
        
        if ((dt < 500) && (dt > 0)) {
            var ln = Math.floor(dt/500.0*pkt.txt.length)
            txt = pkt.txt.slice(0, ln)
        } else if ((dt > 2500) && (dt < 3000)) {
            var ln = Math.floor((1.0 - (3000 - dt)/500.0)*pkt.txt.length)
            txt = pkt.txt.slice(ln)
            dx = ln
        } else if ((dt > 0) && (dt < 3000)) {
            txt = pkt.txt
        }
        
        if (txt) {
            drawAsciiText(pkt.x + dx, pkt.y-1, txt, fg, bg, luma)
        }
    }
    
    if (actionMenuShown) {
        var mx = actionMenuCenter[0], my = actionMenuCenter[1], mw = 0, mh = actionMenuActions.length * 4
        for (var i=0; i < actionMenuActions.length; i++) {
            if (mw < actionMenuActions[i].text.length) {
                mw = actionMenuActions[i].text.length
            }
        }
        
        mx += 2
        my -= Math.floor(mh / 2)
        
        if (my < 0) {
            my = 0
        }
        
        if ((my + mh) >= displaySizeY) {
            my = displaySizeY - mh - 1
        }
        
        if ((mx + mw) >= (displaySizeX - 1)) {
            mx = actionMenuCenter[0] - 3 - mw
        }
        
        var verx = ((lastMove[0] >= mx) && (lastMove[0] < (mx + mw + 2)))
        for (var i=0; i < actionMenuActions.length; i++) {
            var by = my + i * 4
            var very = (lastMove[1] >= by) && (lastMove[1] < (by + 3))
            var verKeyb = menuSel == i
            
            if (verx && very) {
                menuSel = i
            }
            
            var totVer = (verx && very) || verKeyb
            
            if (drawButtonWithText(mx, by, actionMenuActions[i].text, mw + 2, (actionMenuActions[i].fg || opsColsFg)[totVer], (actionMenuActions[i].bg || opsColsBg)[totVer], i)) {
                /*actionMenuShown = false
                lastClick = [-1, -1]
                
                if (mouseActions[actionMenuActions[i].text]) {
                    var pos = actionMenuActions[i].pos || {x: -1, y: -1} // A good fallback to avoid unnecessary logic
                    mouseActions[actionMenuActions[i].text](pos.x, pos.y, actionMenuActions[i])
                }*/
                
                activateMenuAction(i)
            }
        
        }
    }

}

function drawConsoleBar(x, y, w, h, percent, alpha) {
    if (typeof(alpha) === "undefined") {
        alpha = 1.0
    }
    
    var cols = [[255, 0, 0], [255, 255, 0], [0, 255, 0], [0, 0, 255]].map(function(x) { return modulateAlpha(x, alpha) })
    var grayBg = modulateAlpha([64, 64, 64], alpha)
    
    for (var iy=0; iy < h; iy++) {
        for (var ix=0; ix < w; ix++) {
            var p = ix / w
            var cp = Math.floor(p*4)
            var col = cols[cp]
            
            if (p < percent) {
                terminal.setPixel(x + ix, y + iy, 178, col, [0,0,0])
            } else {
                terminal.setPixel(x + ix, y + iy, 178, [0,0,0], grayBg)
            }
        }
    }
}

function pad(txt, l) {
    while (txt.length < l) {
        txt = " " + txt
    }
    
    return txt
}

function padR(txt, l) {
    while (txt.length < l) {
        txt = txt + " "
    }
    
    return txt
}

function drawAsciiText(x, y, txt, fg, bg, luma) {
    for (var i=0; i < txt.length; i++) {
        var c = txt.charAt(i)
        if (c in asciiMapping) {
            terminal.setPixel(x + i, y, asciiMapping[c], fg, bg, luma)
        }
    }
}

function drawBoxedAsciiText(x, y, w, h, txt, fg, bg, luma, separation) {
    var words = txt.split(" ")
    
    if (typeof(separation) === "undefined") {
        separation = 1
    }
    
    var px = x
    var py = y
    for (var i=0; i < words.length; i++) {
        var word = words[i]
        
        if ((word.length + px - x) >= w) {
            px = x
            py += separation
        }
        
        if ((py - y) >= h) {
            return
        }
        
        drawAsciiText(px, py, word, fg, bg, luma)
        px += word.length + 1
    }
}

function drawRexSpriteHCenter(spr, y, dx) {
    if (typeof(dx) === "undefined") {
        dx = 0
    }
    
    return drawRexSprite(Math.floor((displaySizeX - spr.layers[0].width)/2 + dx), y, spr)
}

function drawRexSprite(x, y, spr) {
    var clicked = false
    for (var l=0; l < spr.layers.length; l++) {
        var layer = spr.layers[l]
        
        for (var iy=0; iy < layer.height; iy++) {
            for (var ix=0; ix < layer.width; ix++) {
                var ras = layer.raster[iy + ix * layer.height]
                
                if (!((ras.bg.r == 255) && (ras.bg.g == 0) && (ras.bg.b == 255))) {
                    terminal.setPixel(x + ix, y + iy, ras.asciiCode,
                        [ras.fg.r, ras.fg.g, ras.fg.b],
                        [ras.bg.r, ras.bg.g, ras.bg.b])
                        
                    if ((lastClick[0] == (x + ix))&&(lastClick[1] == (y + iy))) {
                        lastClick[0] = -1
                        lastClick[1] = -1
                        clicked = true
                    }
                }
            }
        }
    }
    
    return clicked
}

function drawRexSpriteAlpha(x, y, spr, alpha) {
    if (typeof(alpha) === "undefined") {
        alpha = 1.0
    }
    
    var clicked = false
    for (var l=0; l < spr.layers.length; l++) {
        var layer = spr.layers[l]
        
        for (var iy=0; iy < layer.height; iy++) {
            for (var ix=0; ix < layer.width; ix++) {
                var ras = layer.raster[iy + ix * layer.height]
                
                if (!((ras.bg.r == 255) && (ras.bg.g == 0) && (ras.bg.b == 255))) {
                    terminal.setPixel(x + ix, y + iy, ras.asciiCode,
                        modulateAlpha([ras.fg.r, ras.fg.g, ras.fg.b], alpha),
                        modulateAlpha([ras.bg.r, ras.bg.g, ras.bg.b], alpha))
                        
                    if ((lastClick[0] == (x + ix))&&(lastClick[1] == (y + iy))) {
                        lastClick[0] = -1
                        lastClick[1] = -1
                        clicked = true
                    }
                }
            }
        }
    }
    
    return clicked
}

function pruneWeaponName(name) {
    //return name.toLocaleLowerCase().replace(/\s/g, '')
    return name.replace(/\s/g, '')
}

var lastAttrs = {}
var tmstmpShowAllHud = 0
function testAttrBeforeDraw(attrName, attrVal, fnDraw) {
    var dn = Date.now()
    var tAll = (dn - tmstmpShowAllHud)
    if (tAll < 3000) {
        if (tAll < 2500) {
            fnDraw(1.0)
        } else {
            fnDraw((3000 - tAll)/500)
        }
    } else if (!(attrName in lastAttrs) || 
        ((dn - lastAttrs[attrName].timeChange) < 3000) ||
        (lastAttrs[attrName].value !== attrVal)) {
        
        if (!(attrName in lastAttrs)) {
            lastAttrs[attrName] = {timeChange: Date.now(), value: attrVal}
        } else if (lastAttrs[attrName].value !== attrVal) {
            lastAttrs[attrName].value = attrVal
            lastAttrs[attrName].timeChange = Date.now()
        }
        
        if ((dn - lastAttrs[attrName].timeChange) < 2500) {
            fnDraw(1.0)
        } else {
            var alpha = (3000 - (dn - lastAttrs[attrName].timeChange))/500
            
            fnDraw(alpha)
        }
    }
}

function modulateAlpha(triad, alpha) {
    return triad.map(function(comp) { return Math.floor(comp * alpha) })
}

function updateAttrs() {
    if (playerAttrs) {
        var y = 0
        
        /*drawAsciiText(displaySizeX + 2, y, "Plyr. " + ownUsername, [0, 255, 0], [0, 0, 0])
        y += 2*/
        var attrsDisplayX = displaySizeX - 33
        if (("cpos" in player) && (player.cpos.x > (displaySizeX / 2))) {
            attrsDisplayX = 2
        }
        
        /*testAttrBeforeDraw("hp", playerAttrs.hp.pos + "/" + playerAttrs.hp.max, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "HP " + pad(playerAttrs.hp.pos, 3) + "/" + playerAttrs.hp.max, modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.hp.pos / playerAttrs.hp.max, alpha)
            y += 2
        })*/
        drawAsciiText(attrsDisplayX, y, "HP " + pad(playerAttrs.hp.pos, 3) + "/" + playerAttrs.hp.max, [0, 255, 0], [0, 0, 0])
        drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.hp.pos / playerAttrs.hp.max)
        y += 2
        
        testAttrBeforeDraw("armor", playerAttrs.armor.pos + "/" + playerAttrs.armor.max, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "AR " + pad(playerAttrs.armor.pos, 3) + "/" + playerAttrs.armor.max, modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.armor.pos / playerAttrs.armor.max, alpha)
            y += 2
        })
        
        testAttrBeforeDraw("strength", playerAttrs.strength.pos + "/" + playerAttrs.strength.max, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "ST " + pad(playerAttrs.strength.pos, 3) + "/" + playerAttrs.strength.max, modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.strength.pos / playerAttrs.strength.max, alpha)
            y += 2
        })
        
        testAttrBeforeDraw("precision", playerAttrs.precision.pos + "/" + playerAttrs.precision.max, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "PR " + pad(playerAttrs.precision.pos, 3) + "/" + playerAttrs.precision.max, modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.precision.pos / playerAttrs.precision.max, alpha)
            y += 2
        })
        
        testAttrBeforeDraw("speed", playerAttrs.speed.pos + "/" + playerAttrs.speed.max, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "SP " + pad(playerAttrs.speed.pos, 3) + "/" + playerAttrs.speed.max, modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.speed.pos / playerAttrs.speed.max, alpha)
            y += 2
        })
        
        testAttrBeforeDraw("battery", Math.round(playerAttrs.battery), function(alpha) {
            drawAsciiText(attrsDisplayX, y, "BAT " + pad(Math.round(playerAttrs.battery), 3), modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            drawConsoleBar(attrsDisplayX + 13, y, 12, 1, playerAttrs.battery / 100, alpha)
            y += 2
        })
        
                
        var firingPrimary = false
        var firingAlternate = false
        
        if (typeof(player.firing) != "undefined") {
            firingPrimary = player.firing == "primary"
            firingAlternate = player.firing == "alternate"
        }
        
        testAttrBeforeDraw("weaponname", currentWeapon.name, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "Weapon", modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            y += 2
            drawAsciiText(attrsDisplayX, y, currentWeapon.name, modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
            y++
        })
        
        var bgColor = firingPrimary?[128, 128, 0]:[0, 0, 0]
        if (typeof(currentWeapon.ammoType) !== "undefined") {
            /*testAttrBeforeDraw("weaponammotype", currentWeapon.ammoType + firingPrimary, function(alpha) {
                drawAsciiText(attrsDisplayX, y, padR(currentWeapon.ammoType, 30), modulateAlpha([0, 255, 0], alpha), modulateAlpha(bgColor, alpha))
                y++
            })*/
            drawAsciiText(attrsDisplayX, y, padR(currentWeapon.ammoType, 30), [0, 255, 0], bgColor)
            y++
        }
        
        if (currentWeapon.ammoMax !== 0) {
            /*testAttrBeforeDraw("weaponammoamnt", currentWeapon.ammo + "/" + currentWeapon.ammoMax, function(alpha) {
                var ammoStr = "Ammo " + pad(currentWeapon.ammo, 3) + "/" + currentWeapon.ammoMax
                drawAsciiText(attrsDisplayX, y, padR(ammoStr, 30), modulateAlpha([0, 255, 0], alpha), modulateAlpha(bgColor, alpha))
                drawConsoleBar(attrsDisplayX + 15, y, 10, 1, currentWeapon.ammo / currentWeapon.ammoMax, alpha)
                y++
            })*/
            var ammoStr = "Ammo " + pad(currentWeapon.ammo, 3) + "/" + currentWeapon.ammoMax
            drawAsciiText(attrsDisplayX, y, padR(ammoStr, 30), [0, 255, 0], bgColor)
            drawConsoleBar(attrsDisplayX + 15, y, 10, 1, currentWeapon.ammo / currentWeapon.ammoMax)
            y++
        }
        
        testAttrBeforeDraw("weapondmg", currentWeapon.ammo + "/" + currentWeapon.ammoMax, function(alpha) {
            drawAsciiText(attrsDisplayX, y, "Dmg. " + currentWeapon.damage[0] + " - " + currentWeapon.damage[1], modulateAlpha([0, 255, 0], alpha), [0, 0, 0])
                y++
        })
            
		if (currentWeapon.alternate) {
            bgColor = firingAlternate?[128, 128, 0]:[0, 0, 0]
            if (typeof(currentWeapon.alternate.ammoType) !== "undefined") {
                /*testAttrBeforeDraw("weaponaltammotype", currentWeapon.alternate.ammoType + firingAlternate, function(alpha) {
                    drawAsciiText(attrsDisplayX, y, padR(currentWeapon.alternate.ammoType, 30), modulateAlpha([0, 255, 128], alpha), modulateAlpha(bgColor, alpha))
                    y++
                })*/
                drawAsciiText(attrsDisplayX, y, padR(currentWeapon.alternate.ammoType, 30), [0, 255, 128], bgColor)
                y++
            }
            
            if (currentWeapon.alternate.ammoMax !== 0) {
                /*testAttrBeforeDraw("weaponaltammoamnt", currentWeapon.alternate.ammo + "/" + currentWeapon.alternate.ammoMax, function(alpha) {
                    var ammoStr = "Ammo " + pad(currentWeapon.alternate.ammo, 3) + "/" + currentWeapon.alternate.ammoMax
                    drawAsciiText(attrsDisplayX, y, padR(ammoStr, 30), modulateAlpha([0, 255, 128], alpha), modulateAlpha(bgColor, alpha))
                    drawConsoleBar(attrsDisplayX + 15, y, 10, 1, currentWeapon.alternate.ammo / currentWeapon.alternate.ammoMax, alpha)
                    y++
                })*/
                var ammoStr = "Ammo " + pad(currentWeapon.alternate.ammo, 3) + "/" + currentWeapon.alternate.ammoMax
                drawAsciiText(attrsDisplayX, y, padR(ammoStr, 30), [0, 255, 128], bgColor)
                drawConsoleBar(attrsDisplayX + 15, y, 10, 1, currentWeapon.alternate.ammo / currentWeapon.alternate.ammoMax)
                y++
            }
		}
		
        if (!((currentWeapon.id in weaponSprites) || (currentWeapon.name in weaponSprites))) {
            
            var f = function(weap) {
                loadGenXpSprite(pruneWeaponName(weap), function(sp) { 
					weaponSprites[weap] = sp 
				})
            }
            var n = currentWeapon.id
            if (n == "------") {
                loadXpSprite(pruneWeaponName(currentWeapon.name.toLowerCase()), (function(nm) {
                        return function(sp) { weaponSprites[nm] = sp }
                    })(currentWeapon.name))
            } else {
                weaponSprites[currentWeapon.id] = undefined
                f(currentWeapon.id)
            }
        } else if (weaponSprites[currentWeapon.id]) {
            var spr = weaponSprites[currentWeapon.id]
            
            testAttrBeforeDraw("weaponsprite", currentWeapon.id, function(alpha) {
                drawRexSpriteAlpha(attrsDisplayX, y, spr, alpha)
            })
        } else if (currentWeapon.name in weaponSprites) {
            var spr = weaponSprites[currentWeapon.name]
            
            testAttrBeforeDraw("weaponsprite", currentWeapon.name, function(alpha) {
                drawRexSpriteAlpha(attrsDisplayX, y, spr, alpha)
            })
        }
        
        var ramp = [[64, 0, 0], [128, 0, 0], [128, 64, 0], [128, 128, 0], [64, 128, 0], [0, 128, 64], [0, 128, 128], [64, 192, 192], [128, 192, 192], [255, 255, 255]]
        
        if (displaySuPow < playerAttrs.suPow) {
            displaySuPow++
        } else if (displaySuPow > playerAttrs.suPow) {
            displaySuPow--
        }
        
        var maxY = displaySizeY - Math.floor(displaySuPow * displaySizeY / 100)
        
        var colorCycle = Math.floor(Date.now() / 50.0)
        //var bg = (maxY <= 0)?ramp[Math.floor((Math.sin(Date.now()/50.0)+1) / 2 * (ramp.length - 1))]:[0,0,0]
        
        var suPowBarX = displaySizeX - 1
        if (("cpos" in player) && (player.cpos.x > (displaySizeX / 2))) {
            suPowBarX = 0
        }
        
        for (var i=displaySizeY - 1; i >= maxY; i--) {
            var fgIdx = ramp.length - Math.floor(i * ramp.length / displaySizeY) - 1
            var bg = (maxY <= 0)?ramp[Math.floor((Math.sin(Date.now()/150.0 + Math.cos(Date.now()/300.0 + i*10.0) * 0.5)+1) / 2 * (ramp.length - 1))]:[0,0,0]
            
            var fg = (maxY <= 0)?[0, 0, 0]:ramp[fgIdx]
            drawAsciiText(suPowBarX, i, "\u25B2", fg, bg)
        }
    }
}

function updateLogs() {
    //drawAsciiText(displaySizeX + 2, 41, "Game log", [0, 255, 0], [0, 0, 0])
    
    var py = 0
    var px = 0
    var dy = 1
    var rightJustified = false
    
    if ("cpos" in player) {
        if (player.cpos.x > (displaySizeX / 2)) {
            rightJustified = true
            px = displaySizeX - 1
        } 
        
        if (player.cpos.y <= 20) {
            py = displaySizeY - 1
            dy = -1
        }
    }
    
    for (var i=0; i < announcements.length; i++) {
        var ann = announcements[i]
        var t = Date.now() - ann.tmstmp
        if (t < 3000) {
            var nx = px
            if (rightJustified) {
                nx -= ann.msg.length
            }
            var fgCol = [64, 200, 64]
            if (t >= 2500) {
                fgCol = modulateAlpha(fgCol, (3000 - t)/500)
            }
            drawAsciiText(nx, py, ann.msg, fgCol, [0, 0, 0])
            py += dy
        }
    }
    
    /*var m = announcements.length-1
    
    var l = Math.min(m, displaySizeY - 39)
    for (var i=0; i < l; i++) {
        var ann = announcements[m - i]
        
        if (ann.length >= 30 ) {
            var granule = 400
            var tmln = granule * (ann.length + 8 - 30)
            var p = Math.floor(((Date.now() % tmln) / granule)) - 4
            if (p < 0) {
                p = 0
            } else if ((p + 30) >= ann.length) {
                p = ann.length - 30
            }
            
            ann = ann.slice(p, p+64)
        }
        
        drawAsciiText(displaySizeX + 2, 42 + i, ann, [64, 200, 64], [0, 0, 0])
    }*/
} 

function showPkts(pkts) {
    currentPkts = currentPkts.concat(pkts.map(function(pkt) {
        pkt.initialTime = Date.now() + Math.floor(Math.random() * 400)
        var txt = "Unknown"
        
        if ('hostile_seen' in pkt.msg) {
            txt = 'Hostile seen!'
        } else if ('need_squad' in pkt.msg) {
            txt = 'Searching squad'
        } else if ('have_squad' in pkt.msg) {
            txt = 'Join my squad ' + pkt.msg.have_squad.squad
        } else if ('retreat' in pkt.msg) {
            txt = 'Retreating'
        } else if ('need_backup' in pkt.msg) {
            txt = 'Backup!!!!'
        } else if ('new_squad' in pkt.msg) {
            txt = 'Formed squad ' + pkt.msg.new_squad.name
        } else if ('exploring' in pkt.msg) {
            txt = 'Team follow me'
        } else if ('retreating' in pkt.msg) {
            txt = 'Retreat!'
        } else if ('joined_squad' in pkt.msg) {
            txt = 'Joined ' + pkt.msg.joined_squad.squad
        } else {
            console.log(pkt)
        }
        
        pkt.txt = txt
        
        return pkt
    }))
    
    var i = 0
    while (i < currentPkts.length) {
        var pkt = currentPkts[i]
        
        if ((Date.now() - pkt.initialTime) >= 1000) {
            currentPkts.splice(i, 1)
        } else {
            i++
        }
    }
}

function absolutePosToWindow(x, y) {
    /*if (x < minCoords.x) {
        x = minCoords.x
    } else if (x >= minCoords.x + displaySizeX) {
        x = minCoords.x + displaySizeX - 1
    }
    
    if (y < minCoords.y) {
        y = minCoords.y
    } else if (y >= minCoords.y + displaySizeY) {
        y = minCoords.y + displaySizeY - 1
    }
    
    var tx = x - minCoords.x
    var ty = y - minCoords.y
    
    var table = $("#term")
    var cl = $(table[0].rows[ty].cells[tx])
    
    return cl.offset()*/
    
}

function spawnParticles() {
    if (typeof(particles) != "undefined") {
        for (var i=0; i < particles.length; i++) {
            var part = particles[i]

            if (part.movType == "instant") {
                if (!part.route) {
                    part.route = TraceLine(part.ox, part.oy, part.dx, part.dy).reverse()
                    part.routeStart = Date.now() + part.delay
                    part.timeGranule = part.ttl / part.route.length
                }
                
                var pos = part.route[part.route.length - 1]
                if (pos) {
                    if ((pos[1] >= 0)&&(pos[1] < level.length)&&
                            (pos[0] >= 0)&&(pos[0] < level[0].length)) {
                        level[pos[1]][pos[0]].particles.push(part)
                    }
                }
            }
        }
    }
}

function initAsciiDisplay(id, w, h) {
    terminal = new ASCIITerminal({
        font: './static/CGA8x8thick.png',
        target: 'term',
        console: {width: w, height: h},
        consoleScale: (localStorage.dupConSz == "true")?2:1,
        use2xsai: localStorage.use2xsai == "true"
    })
    
    terminal.ready(function() {
        render()
    })
    
    terminal.on('click', function(x, y) {
        clickCell(x, y)
    })
    
    terminal.on('mousemove', function(x, y) {
        moveCell(x, y)
    })
}

var mustUpdateFsms = false
var handlers = {
    init: function(obj) {
        announceMsg("Initializing game")
        console.log(obj)
        player.pos = obj.pos
        levelTileset = obj.levelTileset
        canCheat = obj.canCheat
        
        if (canCheat) {
            var s = document.createElement("script")
            s.type = "text/javascript"
            s.src = "https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"
            $(document.body).append(s)
        }
        
        for (var y=0; y < obj.dim.h; y++) {
            var row = Array.apply(null, new Array(obj.dim.w+1)).map(function(){return {particles: []}})
            level.push(row)
        }
        
        /*var lst = $("#player_list")
        for (var i=0; i < obj.player_list.length; i++) {
            var plyr = obj.player_list[i]
            if (!(plyr.username in playerDivs)) {
                var dv = $("<div>")
                dv.text(plyr.username)
                
                lst.append(dv)
                if (plyr.username == ownUsername) {
                    dv.css("color", "#04f")
                } else {
                    dv.css("color", "#ff0")
                }
                playerDivs[plyr.username] = dv
            }
        }*/
        
        useSounds = localStorage.useSound == "true"
        gameStarted = true
        pos()
    },
    pos: function(obj) {
        player.pos.x = obj.plyr_pos.x
        player.pos.y = obj.plyr_pos.y
        player.fov = obj.fov
        player.crouch = obj.crouch
		player.prone = obj.prone
        turn++
        
        for (var y=0; y < obj.scope.length; y++) {
            var py = y + obj.pos.y
            
            if ((py >= 0)&&(py < level.length)) {
                for (var x=0; x < obj.scope[y].length; x++) {
                    var px = x + obj.pos.x
                    
                    if ((px >= 0) && (px < level[y + obj.pos.y].length)) {
                        if (obj.scope[y][x]) {
                            var sc = obj.scope[y][x]
                            sc.turn = turn
                            sc.particles = level[py][px].particles
                            level[py][px] = sc
                        }
                    }
                }
            }
        }
        
        particles = obj.particles
        
        if (typeof(obj.attrs) != "undefined") {
            playerAttrs = obj.attrs
        }
        
        updateWeapon(obj.weapon)
        
        updateDisplay()
        
        if ("damaged" in obj) {
            showDamage = obj.damaged?30:0
            
            if ((typeof(destinationPath) !== "undefined") && (destinationPath.length > 0)) {
                destinationPath = undefined
            }
        }
        
        if ("inventory" in obj) {
            inventoryList = obj.inventory
        }
        
        if (useSounds) {
            for (var i=0; i < obj.snds.length; i++) {
                var snd = obj.snds[i]
                
                createjs.Sound.play(snd.s, {
                    volume: snd.v/128.0,
                    pan: snd.p/128.0,
                    delay: snd.d
                })
            }
        }
        
        spawnParticles()
        if (("couldMove" in obj) && (obj.couldMove)) {
            tryMoveTowardsDestination() // If there's a standing command, move
        }
        
        if (obj.fsms) {
            for (var i=0; i < obj.fsms.length; i++) {
                console.log(obj.fsms[i])
            }
        }
        
        if (mustUpdateFsms) {
            cheat('updatefsms')
        }
        
        if (obj.pkts) {
            showPkts(obj.pkts)
        }
    },
    new_player: function(obj) {
        announceMsg("Player " + obj.username + " joined the game!")
        var lst = $("#player_list")
        var dv = $("<div>")
        dv.text(obj.username + " (" + obj.player_class + ")")
        
        if (obj.username == ownUsername) {
            dv.css("color", "#04f")
        } else {
            dv.css("color", "#ff0")
        }
        
        lst.append(dv)
        playerDivs[obj.username] = dv
    },
    player_left: function(obj) {
        announceMsg("Player " + obj.username + " left the game!")
        /*var dv = playerDivs[obj.username]
        dv.remove()*/
    },
    player_died: function(obj) {
        var dv = playerDivs[obj.username]
        dv.css("color", "#800")
        if (typeof(obj.reason) != "undefined") {
            if (obj.reason == "lava") {
                announceMsg("Player " + obj.username + " took a dive into lava")
            } else if (obj.reason == "acid") {
                announceMsg("Player " + obj.username + " decided to shed some skin on acid")
            } else if (obj.reason == "plasma") {
                announceMsg("Player " + obj.username + "'s subatomic particles got disorganized")
            } else if (obj.reason == "9mm") {
                announceMsg("Player " + obj.username + " bled through tiny holes")
            } else if (obj.reason == "9mm FMJ") {
                announceMsg("Player " + obj.username + " internal organs failed")
            } else if (obj.reason == "12ga shells") {
                announceMsg("Player " + obj.username + " was splattered on the walls")
            } else {
                announceMsg("Player " + obj.username + " died: " + obj.reason)
            }
        } else {
            announceMsg("Player " + obj.username + " died")
        }
    },
    player_downstairs: function(obj) {
        var dv = playerDivs[obj.username]
        dv.css("color", "#FFF")
        announceMsg("Player " + obj.username + " went downstairs")
    },
    inventory: function(obj) {
        inventoryList = obj.inventory
    },
    new_level: function(obj) {
        announceMsg("You enter a new level!")
        gameStarted = false
        while (level.length > 0) {
            level.pop()
        }
    },
    fsm_vars: function(obj) {
        console.log(obj)
        mustUpdateFsms = true
    },
    fsms_updates: function(obj) {
        for (x in obj.fsms) {
            if (obj.fsms.hasOwnProperty(x)) {
                updateFsm(obj.fsms[x], x)
            }
        }
    }
}

var fsmDivs = {}
function updateFsm(fsm, id) {
    var dv, title
    if (id in fsmDivs) {
        dv = fsmDivs[id]
        title = dv.find('h3')
    } else {
        dv = $("<div>")
        dv.draggable()
        dv.addClass('fsm')
        title = $("<h3>")
        dv.append(title)
        
        fsmDivs[id] = dv
        
        $(document.body).append(dv)
    }
    title.text(fsm.currentState.name)
    
    for (name in fsm.variables) {
        if (fsm.variables.hasOwnProperty(name)) {
            var value = fsm.variables[name]
            
            var sp = dv.find('#' + id + '_' + name), b, t
            
            if (sp.length == 0) {
                sp = $("<div>")
                sp[0].id = id + '_' + name
                b = $("<b>")
                sp.append(b)
                t = $("<i>")
                sp.append(t)
            } else {
                b = sp.find('b')
                t = sp.find('i')
            }

            b.text(name + ":")
            
            if ((typeof(value) === "object") && ('x' in value) && ('y' in value)) {
                t.text('(' + value.x + ', ' + value.y + ')')
            } else {
                t.text(value)
            }
            
            dv.append(sp)
        }
    }
}

var wsPortPart = ":8080"
if (window.location.hostname.indexOf("ganymedegate") >= 0) {
    // OpenShift needs the WebSocket to connect to port 8000
    wsPortPart = ":8000"
}

function startConnection() {
    var sck = new WebSocket("ws://" + (window.location.hostname || "127.0.0.1") + wsPortPart)
    sck.onopen = function (event) {
        //
    }

    sck.onmessage = function (event) {
        //totalChars += event.data.length
        //console.log("~" + (totalChars/1024) + " Kb")*/
        var msg = JSON.parse(pako.inflate(event.data, { to: 'string' }))
        
        if (typeof(msg.type) != 'undefined') {
            handlers[msg.type](msg)
        }
        
        if (typeof(msg.msgs) != 'undefined') {
            queueAnnouncements(msg.msgs)
        }
    }

    sck.onclose =  function (event) {
        console.log("Close: " + event)
    }

    sck.onerror =  function (event) {
        console.log("Error: " + event)
    }
    
    return sck
}

var sock = startConnection()

function reconnect() {
    sock.close()
    sock = startConnection()
}

function send(obj) {
    sock.send(JSON.stringify(obj))
}

var fnCommands = {
    up: function(shift) {
        if (gameStarted) {
            if (actionMenuShown) {
                menuSel -= 1
                if (menuSel < 0) {
                    menuSel += actionMenuActions.length
                }
            } else if (showingInventory) {
                inventoryIndex--
            } else if (keyboardLook) {
                moveCell(lastMove[0], Math.max(0, lastMove[1] - 1))
                return "cursor"
            } else {
                destinationPath = undefined
                pos(0, -1, shift)
            }
        } else {
            menuSel = menuSel - 1
            if (menuSel < 0) {
                menuSel += menuOptionsNumber
            }            
        }
    },
    down: function(shift) {
        if (gameStarted) {
            if (actionMenuShown) {
                menuSel = (menuSel + 1) % actionMenuActions.length
            } else if (showingInventory) {
                inventoryIndex++
            } else if (keyboardLook) {
                moveCell(lastMove[0], Math.min(displaySizeY - 1, lastMove[1] + 1))
                return "cursor"
            } else {
                destinationPath = undefined
                pos(0, 1, shift)
            }
        } else {
            menuSel = (menuSel + 1) % menuOptionsNumber
        }
    },
    left: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.max(0, lastMove[0] - 1), lastMove[1])
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                destinationPath = undefined
                pos(-1, 0, shift)
            }
        }
    },
    right: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.min(displaySizeX - 1, lastMove[0] + 1), lastMove[1])
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                destinationPath = undefined
                pos(1, 0, shift)
            }
        }
    },
    upleft: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.max(0, lastMove[0] - 1), Math.max(0, lastMove[1] - 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                destinationPath = undefined
                pos(-1, -1, shift)
            }
        }
    },
    upright: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.min(displaySizeX - 1, lastMove[0] + 1), Math.max(0, lastMove[1] - 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                destinationPath = undefined
                pos(1, -1, shift)
            }
        }
    },
    downright: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.min(displaySizeX - 1, lastMove[0] + 1), Math.min(displaySizeY - 1, lastMove[1] + 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                destinationPath = undefined
                pos(1, 1, shift)
            }
        }
    },
    downleft: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.max(0, lastMove[0] - 1), Math.min(displaySizeY - 1, lastMove[1] + 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                destinationPath = undefined
                pos(-1, 1, shift)
            }
        }
    },
    wait: function(shift) {
        if (keyboardLook) {
        } else if (actionMenuShown) {
            // Do nothing
        } else {
            destinationPath = undefined
            pos(0, 0, shift)
        }
    },
	prone: function() {
		prone()
	},
	crouch: function() {
		crouch()
	},
    toggleKeyboardLook: function() {
        if (gameStarted && !showingInventory) {
            keyboardLook = !keyboardLook
            
            if (keyboardLook) {
                lastMove = [player.cpos.x, player.cpos.y]
                
                return "cursor"
            }
        }
    }
}

function shutdownKeyboardLook() {
    keyboardLook = false
    lastMove = [-1, -1]
}

function cancelEverything() {
    shutdownKeyboardLook()
    cancelTarget()
    finishEditText()
    showingInventory = false
    actionMenuShown = false
}

function showAllHud() {
    tmstmpShowAllHud = Date.now()
    if (announcements.length > 0) {
        var n = announcements.length - 1
        var i = 5
        var dt = Date.now()
        
        while ((n >= 0) && (i > 0)) {
            announcements[n].tmstmp = dt + i * 3000
            n--
            i--
        }
    }
}

var kb_hnd = {
    // Up group
    "Up": fnCommands.up,
    "k": fnCommands.up,
    "U+004B": fnCommands.up,
    "w": fnCommands.up,
    "U+0057": fnCommands.up,
    
    // Down group
    "Down": fnCommands.down,
    "j": fnCommands.down,
    "U+004A": fnCommands.down,
    "s": fnCommands.down,
    "U+0053": fnCommands.down,
    
    // Left group
    "Left": fnCommands.left,
    "h": fnCommands.left,
    "U+0048": fnCommands.left,
    "a": fnCommands.left,
    "U+0041": fnCommands.left,
    
    // Right group
    "Right": fnCommands.right,
    "l": fnCommands.right,
    "U+004C": fnCommands.right,
    "d": fnCommands.right,
    "U+0044": fnCommands.right,
    
    // Upleft group
    "Home": fnCommands.upleft,
    "y": fnCommands.upleft,
    "U+0059": fnCommands.upleft,
    "q": fnCommands.upleft,
    "U+0051": fnCommands.upleft,
    
    // Upright group
    "PageUp": fnCommands.upright,
    "u": fnCommands.upright,
    "U+0055": fnCommands.upright,
    "e": fnCommands.upright,
    "U+0045": fnCommands.upright,
    
    // Downright group
    "PageDown": fnCommands.downright,
    "n": fnCommands.downright,
    "U+004E": fnCommands.downright,
    "c": fnCommands.downright,
    "U+0043": fnCommands.downright,
    
    // Downleft group
    "End": fnCommands.downleft,
    "b": fnCommands.downleft,
    "U+0042": fnCommands.downleft,
    "z": fnCommands.downleft,
    "U+005A": fnCommands.downleft,
    
    // Wait group
    "Clear": fnCommands.wait,
    ".": fnCommands.wait,
    "U+002E": fnCommands.wait,
    "x": fnCommands.wait,
    "U+0058": fnCommands.wait,
    
    " ": use,
    "U+0020": use,
    
    "g": grab,
    "U+0047": grab,
    
    "f": fire,
    "U+0046": fire,
    
    "t": superPower,
    "U+0054": superPower,
    
    "r": reload,
    "U+0052": reload,
	
	"p": fnCommands.prone,
    "U+0050": fnCommands.prone,
	
	"o": fnCommands.crouch,
    "U+004F": fnCommands.crouch,
    
    "U+00BA": showTips, // Tab
    "i": toggleInventory,
    "U+0049": toggleInventory,
    
    "v": fnCommands.toggleKeyboardLook,
    "U+0056": fnCommands.toggleKeyboardLook,
    
    "U+001B": cancelEverything,
    "U+00DB": showAllHud,
}

function render() {
    updateDisplay()
    if (terminal) {
        terminal.render(showDamage)
        if (showDamage > 0) {
            showDamage--
        }
    }
    requestAnimationFrame(render)
}

var preventNextKeypress = false
var gameInputEnabled = true

function disableGameInput() {
    gameInputEnabled = false
}

function enableGameInput() {
    gameInputEnabled = true
}

function collectStyleSheetRules() {
    for (var rl=0; rl < document.styleSheets.length; rl++) {
        var rules = document.styleSheets[rl].rules
        
        if ((rules) && (typeof(rules.length) != "undefined")) {
            for (var i=0; i < rules.length; i++) {
                var rule = rules[i]
                if (rule.selectorText && (rule.selectorText.charAt(0) == '.')) {
                    cssRules[rule.selectorText.slice(1)] = rule
                }
            }
        }
    }
}

function toggle_help() {
    $("#help").toggle()
}

function updateShaders() {
    var fs = $("#fs-edit").val()
    var vs = $("#vs-edit").val()
    
    ASCIITerminal.util.fragmentShaders["default"] = fs
    ASCIITerminal.util.vertexShaders["default"] = vs
    
    terminal.gl.shaderProgram = ASCIITerminal.util.initShaders(terminal.gl)[0]
}

function setupMusic() {
    if (localStorage.useMusic == "true") {
        if (!bgm && !gameStarted) {
            bgm = createjs.Sound.play("seedybg", {
                        volume: 0.5,
                        loop: -1
                    })
        } else {
            bgm.play()
        }
        
    } else {
        bgm.stop()
    }
}

function menuUse(n) {
    if (typeof(n) != "undefined") {
        menuSel = n
        lastClick = [-1, -1]
    }
    
    if (currentMenu == 0) {
        // Start menu
        if (menuSel == 0) {
            if (!tutorialSeen) {
                tutorialSeen = true
                localStorage.tutorialSeen = TUTORIAL_VERSION
                currentMenu = 4
                menuSel = 1
                tutorialPage = 0
            } else {
                currentMenu = 1
                menuSel = 0
            }
        } else if (menuSel == 1) {
            currentMenu = 2
            menuSel = 0
        } else if (menuSel == 2) {
            currentMenu = 3
            menuSel = 0
        } else if (menuSel == 3) {
            if (!tutorialSeen) {
                currentMenu = 1
                menuSel = 0
            } else {
                tutorialSeen = true
                localStorage.tutorialSeen = TUTORIAL_VERSION
                currentMenu = 4
                menuSel = 1
                tutorialPage = 0
            }
        } else if (menuSel == 4) {
            window.close()
        }
    } else if (currentMenu == 1) {
        // Char select
        if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 0
            finishEditText()
        } else if (menuSel == (itemsPerMenu[currentMenu] - 2)) {
            beginEditText(ownUsername, function(x, finished) {
                ownUsername = x
                if (finished) {
                    start()
                }
            })
        } else {
            playerPickClass = playerClasses[menuSel].id
            
            if (typeof(ownUsername) === "undefined") {
                menuUse(playerClasses.length)
            } else {
                finishEditText()
                start()
            }
        }
    } else if (currentMenu == 2) {
        // Options
        if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 1
        } else if (menuSel == 0) {
            localStorage.dupConSz = !(localStorage.dupConSz == "true")
        } else if (menuSel == 1) {
            localStorage.use2xsai = !(localStorage.use2xsai == "true")
        } else if (menuSel == 2) {
            localStorage.useMusic = !(localStorage.useMusic == "true")
            setupMusic()
        } else if (menuSel == 3) {
            localStorage.useSound = !(localStorage.useSound == "true")
        } else if (menuSel == 4) {
            currentMenu = 5
            menuSel = 0
        }
    } else if (currentMenu == 3) {
        // Contact
        if (menuSel == 0) {
            //window.open("https://www.vinumeris.com/lighthouse")
            currentMenu = 0
            menuSel = 2
        /*} else if (menuSel == 1) {
            window.open("https://lighthouse.bitseattle.com/lighthouse-projects/ganymede-gate-fundraiser.lighthouse-project")
        } else if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 2*/
        }
    } else if (currentMenu == 4) {
        if (menuSel == 0) {
            tutorialPage = tutorialPage - 1
        } else if (menuSel == 1) {
            tutorialPage = tutorialPage + 1
        } else if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 0
        }
    } else if (currentMenu == 5) {
        if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 2
            menuSel = 4
        } else if (menuSel == (itemsPerMenu[currentMenu] - 2)) {
            saveKeyBindings()
            currentMenu = 2
            menuSel = 4
        } else {
            inspectKeyboardCodes = true
            inspectKeyboardIndex = menuSel
            inspectKeyboardIdentifier = keybindingsMenuIdentifier[menuSel]
        }
    }
    
    menuOptionsNumber = itemsPerMenu[currentMenu]
}

function str2ab(str) {
  var buf = new ArrayBuffer(str.length);
  var bufView = new Uint8Array(buf);
  for (var i=0, strLen=str.length; i<strLen; i++) {
    bufView[i] = str.charCodeAt(i) & 0xFF;
  }
  return buf;
}

function loadXpSprite(name, callback) {
    var xhr = new XMLHttpRequest()
    var port = (window.location.hostname.indexOf("ganymedegate") < 0)?":8080":""
    xhr.open('GET', "http://" + (window.location.hostname || "127.0.0.1") + port + "/static/" + name + ".xp", true)
    xhr.responseType = 'arraybuffer'
     
    xhr.onload = function(e) {
        // response is unsigned 8 bit integer
        if (this.status == 200) {
            var data = data = pako.inflate(new Uint8Array(this.response))
            data.alreadyDecompressed = true
            var sp = new rexSprite.RexSprite(data)

            callback(sp)
        }
    }
     
    xhr.send()
}

function loadGenXpSprite(name, callback, noretry) {
	setTimeout(function() {
        var port = (window.location.hostname.indexOf("ganymedegate") < 0)?":8080":""
		$.ajax("http://" + (window.location.hostname || "127.0.0.1") + port + "/generated/" + name + ".xp", {
			success: function(data) {
				data = pako.inflate(atob(data))
				data.alreadyDecompressed = true
				var sp = new rexSprite.RexSprite(data)
				
				callback(sp)
			},
			error: function(xhr) {
                if (!noretry) {
                    noretry = 0
                }
                
				if (noretry < 5) {
					if (xhr.statusCode().status == 404) {
						setTimeout(function() {
                            console.log("Trying again to load: " + name)
							loadGenXpSprite(name, callback, noretry + 1)
						}, 1000)
					}
				}
			}
		})
	}, 500)
}

function keyIdentifierToText(keyId) {
    if (keyId.startsWith("U+")) {
        var code = parseInt(keyId.slice(2), 16)
        if (code == 32) {
            keyId = "Space"
        } else if (code == 127) {
            keyId = "Delete"
        } else if (code == 144) {
            keyId = "NumLock"
        } else {
            keyId = String.fromCharCode(code)
        }
    }
    
    return keyId
}

/*
    "Up": fnCommands.up,
    "Down": fnCommands.down,
    "Left": fnCommands.left,
    "Right": fnCommands.right,
    "Home": fnCommands.upleft,
    "PageUp": fnCommands.upright,
    "PageDown": fnCommands.downright,
    "End": fnCommands.downleft,
    "Clear": fnCommands.wait,
    " ": use,
    "g": grab,
    "f": fire,
    "t": superPower,
    "r": reload,
	"p": fnCommands.prone,
	"o": fnCommands.crouch,
    "i": toggleInventory,
    "v": fnCommands.toggleKeyboardLook,

keybindingsMenuIdentifier = ["Left", "Right", "Up", "Down", "UpLeft", "DownLeft", "UpRight", 
            "DownRight", "Wait", "Inventory", "Fire", "Reload", "View", "Grab", "SuperPow", "Activate", ]
*/
var positionalKeyBindingHandler = [
    fnCommands.left,
    fnCommands.right,
    fnCommands.up,
    fnCommands.down,
    fnCommands.upleft,
    fnCommands.downleft,
    fnCommands.upright,
    fnCommands.downright,
    fnCommands.wait,
    toggleInventory,
    fire,
    reload,
    fnCommands.toggleKeyboardLook,
    grab,
    superPower,
    use,
    prone,
    crouch
    ]
    
var inspectKeyboardCodes = false
$(document).ready(function () {
    $(document).keyup(function (event) {
        if (!editMode) {
            event = window.event || event
            var k = event.keyIdentifier || event.key
            var keyId = keyIdentifierToText(event.keyIdentifier || event.originalEvent.keyIdentifier)
            
            if (inspectKeyboardCodes) {
                console.log(k)
                
                keyBindingNames[inspectKeyboardIndex] = keyId
                inspectKeyboardCodes = false
                inspectKeyboardIndex = -1
                inspectKeyboardIdentifier = ""
                
                event.preventDefault()
                lastClick[0] = -1
                lastClick[1] = -1
                return
            }
            
            var alreadyHandled = false
            var res
            if (gameStarted) {
                for (var i=0; i < keyBindingNames.length; i++) {
                    if (keyBindingNames[i] == keyId) {
                        alreadyHandled = true
                        res = positionalKeyBindingHandler[i](event.shiftKey)
                        event.preventDefault()
                        break
                    }
                }
            }
            
            if (!alreadyHandled && (k in kb_hnd)) {
                res = kb_hnd[k](event.shiftKey)
                
                event.preventDefault()
            }
            
            if ((res != "cursor") && (k !== "Shift")) {
                lastMove[0] = -1
                lastMove[1] = -1
                
                lastClick[0] = -1
                lastClick[1] = -1
            }
        } else {
            event = window.event || event
            
            if ((event.keyCode == 8)||
                (event.keyCode == 37)||
                (event.keyCode == 39)) {
                editCallback(event.keyCode)
                event.preventDefault()
            }
        }
    })
    
    $(document).keydown(function (event) {
        if (!editMode) {
            event = window.event || event
            var k = event.keyIdentifier || event.key
            if (k in kb_hnd) {
                preventNextKeypress == true
                event.preventDefault()
            }
        } else {
            event = window.event || event
            
            if ((event.keyCode == 8)||
                (event.keyCode == 37)||
                (event.keyCode == 39)) {
                event.preventDefault()
            }
        }
    })
    
    $(document).keypress(function (event) {
        if (!editMode) {//(gameStarted && gameInputEnabled) {
            event = window.event || event
            var k = event.keyIdentifier || event.key
            
            if (preventNextKeypress || (k in kb_hnd)) {
                preventNextKeypress = false
                event.preventDefault()
            }
        } else {
            event = window.event || event
            editCallback(event.charCode)
            event.preventDefault()
        }
        
        if ((event.keyCode == 44)) {
            $("#shaders-edit").toggle()
        }
    })
    
    $("#fs-edit").val(ASCIITerminal.util.fragmentShaders["default"])
    $("#vs-edit").val(ASCIITerminal.util.vertexShaders["default"])
    
    if (localStorage.inited == "true") {
        pickClass(localStorage.chartype)
        tutorialSeen = localStorage.tutorialSeen === (""+TUTORIAL_VERSION)
    } else {
        localStorage.inited = true
        localStorage.dupConSz = false
        localStorage.use2xsai = false
        localStorage.useMusic = true
        localStorage.useSound = true
        localStorage.tutorialSeen = false
        
        pickClass("marine")
    }
    
    loadXpSprite("title", function(sp) { titleSprite = sp })
    loadXpSprite("ganymede", function(sp) { ganymedeSprite = sp })
    loadXpSprite("gplus", function(sp) { gplusSprite = sp })
    loadXpSprite("twitter", function(sp) { twitterSprite = sp })
    loadXpSprite("reddit", function(sp) { redditSprite = sp })
    //loadXpSprite("lighthouse", function(sp) { lighthouseSprite = sp })
    
    initAsciiDisplay('term', displaySizeX, displaySizeY)
    
    createjs.Sound.registerSound("./sounds/9mmpistol.wav", "9mmpistol")
    createjs.Sound.registerSound("./sounds/rpg.wav", "rpg")
    createjs.Sound.registerSound("./sounds/shotgun.wav", "shotgun")
    createjs.Sound.registerSound("./sounds/pickup.wav", "pickup")
    createjs.Sound.registerSound("./sounds/empty_gun.wav", "empty_gun")
    createjs.Sound.registerSound("./sounds/dirt_step.wav", "dirt_step")
    createjs.Sound.registerSound("./sounds/water_step.wav", "water_step")
    createjs.Sound.registerSound("./sounds/acid_step.wav", "acid_step")
    createjs.Sound.registerSound("./sounds/lava_step.wav", "lava_step")
    createjs.Sound.registerSound("./sounds/plasma_step.wav", "plasma_step")
    createjs.Sound.registerSound("./sounds/metal_step.wav", "metal_step")
    createjs.Sound.registerSound("./sounds/reload.wav", "reload")
    createjs.Sound.registerSound("./sounds/hit.wav", "hit")
    createjs.Sound.registerSound("./sounds/gibs.wav", "gibs")
    createjs.Sound.registerSound("./sounds/open_door.wav", "open_door")
    createjs.Sound.registerSound("./sounds/switch.wav", "switch")
    
    // Laser sounds
    createjs.Sound.registerSound("./sounds/laserPistol.wav", "laserPistol")
    createjs.Sound.registerSound("./sounds/laserRifle.wav", "laserRifle")
    createjs.Sound.registerSound("./sounds/laserHeavy.wav", "laserHeavy")
    createjs.Sound.registerSound("./sounds/laserGatling.wav", "laserGatling")
    
    // Plasma sounds
    createjs.Sound.registerSound("./sounds/plasmaPistol.wav", "plasmaPistol")
    createjs.Sound.registerSound("./sounds/plasmaRifle.wav", "plasmaRifle")
    createjs.Sound.registerSound("./sounds/plasmaLauncher.wav", "plasmaLauncher")
    createjs.Sound.registerSound("./sounds/plasmaGatling.wav", "plasmaGatling")
    
    createjs.Sound.registerSound("./sounds/sniperRifle.wav", "sniperRifle")
    
    createjs.Sound.registerSound("./sounds/sword.wav", "sword")
    createjs.Sound.registerSound("./sounds/hammer.wav", "hammer")
    
    createjs.Sound.registerSound("./sounds/radio001.wav", "radio001")
    createjs.Sound.registerSound("./sounds/radio002.wav", "radio002")
    createjs.Sound.registerSound("./sounds/radio003.wav", "radio003")
    createjs.Sound.registerSound("./sounds/radio004.wav", "radio004")
    
    createjs.Sound.on("fileload", function() {
        setupMusic()
    })
    createjs.Sound.registerSound("./sounds/seedybg.wav", "seedybg")
    
    loadKeyBindings()
    
    if (typeof(require) !== "undefined") {
        if (localStorage.dupConSz) {
            window.resizeTo(1600, 1060)
        }
    }
    
    if (window.location.hostname.toLowerCase().indexOf("ganymedegate.com") >= 0) {
        showOrigin()
    }
})

function showOrigin() {
    window.twttr=(function(d,s,id){var t,js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id)){return}js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);return window.twttr||(t={_e:[],ready:function(f){t._e.push(f)}})}(document,"script","twitter-wjs"));
    $(".onlyorigin").show()
}

function goFullScreen() {
    if (
        document.fullscreenEnabled || 
        document.webkitFullscreenEnabled || 
        document.mozFullScreenEnabled ||
        document.msFullscreenEnabled
        ) {
        var i = document.getElementById("term");
         
        // go full-screen
        if (i.requestFullscreen) {
            i.requestFullscreen();
        } else if (i.webkitRequestFullscreen) {
            i.webkitRequestFullscreen();
        } else if (i.mozRequestFullScreen) {
            i.mozRequestFullScreen();
        } else if (i.msRequestFullscreen) {
            i.msRequestFullscreen();
        }
    }
}
</script>
</body>
</html>