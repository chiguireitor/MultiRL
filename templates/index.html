<!DOCTYPE html>
<html>
<head>
<title>Ganymede Gate</title>
<!--link rel="stylesheet" href="/templates/style.css"-->
<style>
.itchio {
    display: block;
    margin: 10px auto;
}

.onlyorigin {
    display: none;
}

.mail-list {
    text-align: center;
    width: 30%;
    margin: 0 auto;
    padding: 15px;
    display: block;
    color: #FFF;
    background-color: #444;
    border-radius: 5px 5px;
    text-decoration: none;
    font-family: calibri, tahoma, helvetica, sans;
}

.fsm {
    color: #0C0;
    border: 1px solid #4A4;
    background-color: #222;
    width: 200px;
    float: left;
}
</style>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="viewport" content="width=device-width, initial-scale=0.6, maximum-scale=0.6, user-scalable=0"/>
</script>
</head>
<body style="background: #000; overflow: hidden">

<div class="ascii" style="width: 100; text-align: center">
<div id="term" style="display: inline; cursor: none">
</div>
</div>
<a class="twitter-share-button onlyorigin"
  href="https://twitter.com/share?url=http://ganymedegate.com&via=johnvillarz&text=Played Ganymede Gate a pre-alpha multiplayer roguelike in development, come join me!&hashtags=roguelike">
Tweet
</a>

<div id="players" style="display: none">
<p><b>Players</b></p>
<div id="player_list">
</div>
</div>

<div style="width: 100%" id="announce">
</div>

<a href="http://eepurl.com/bysGjP" target="_blank" class="mail-list onlyorigin" style="display: none">Click to subscribe to Ganymede Gate's mailing list</a>

<iframe src="//itch.io/embed/36939?dark=true&amp;linkback=true" class="itchio onlyorigin" width="552" height="167" frameborder="0"></iframe>

<a href="https://github.com/chiguireitor/MultiRL" class="onlyorigin"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
<a href="https://gitter.im/chiguireitor/MultiRL" class="onlyorigin">Chat on gitter</a>

<script id="default-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform vec2 fontSize;
    uniform sampler2D uFont, uGlyphs, uForeground, uBackground, uLuma;
    uniform float damageRadius;
    uniform float uWidthDistort;
    uniform float uConsoleCharWidth;
    uniform int uUseLuma;

    void main(void) {
        //float x = gl_FragCoord.x / fontSize.x / 96.0 /* Console char width*/ * uWidthDistort;
        float x = gl_FragCoord.x / fontSize.x / uConsoleCharWidth * uWidthDistort;
        float y = gl_FragCoord.y / 512.0;
        
        float cx = fract(gl_FragCoord.x / fontSize.x) / 16.0;
        float cy = fract(gl_FragCoord.y / fontSize.y) / 16.0;
        
        vec4 glyph = texture2D(uGlyphs, vec2(x, y));
        
        // That green and red channel mingling? Yeah that's because some
        // mobile devices have less than 8 bits per channel
        float gp = floor(glyph.r * 256.0 + floor((glyph.g * 16.0) * 256.0)) / 16.0;
        float gy = 0.9375 - (floor(gp) / 16.0);
        float gx = gp - floor(gp);
        
        vec4 fnt = texture2D(uFont, vec2(gx + cx, gy + cy));
        vec4 fg = texture2D(uForeground, vec2(x, y));
        vec4 bg = texture2D(uBackground, vec2(x, y));
        
        gl_FragColor = mix(fg, bg, fnt.a); // Without scanlines
        //gl_FragColor = mix(fg, bg, fnt.a) * (min(mod(gl_FragCoord.y, 3.0), 2.0)/4.0 + 0.5); // With scanlines
        
        // These "if"s are for the damage radius around the screen edge
        float v = damageRadius;
        if (gl_FragCoord.x <= v){
            float d = (v - gl_FragCoord.x) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        } else if ((gl_FragCoord.x >= (512.0 - v)) && (gl_FragCoord.x <= 512.0)) {
            float d = (v - (512.0 - gl_FragCoord.x)) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        }
        
        if ((gl_FragCoord.y <= v) && (gl_FragCoord.x <= 512.0)) {
            float d = (v - gl_FragCoord.y) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        } else if ((gl_FragCoord.y >= (512.0 - v)) && (gl_FragCoord.x <= 512.0)) {
            float d = (v - (512.0 - gl_FragCoord.y)) / 20.0;
            
            gl_FragColor.r = gl_FragColor.r + d;
        }
        
        if (uUseLuma == 1) {
            vec4 luma = texture2D(uLuma, vec2(x, y));
            
            gl_FragColor = vec4(gl_FragColor.r * luma.r, gl_FragColor.g * luma.g, gl_FragColor.b * luma.b, gl_FragColor.a);
        }
    }
</script>

<script id="rtt-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        vec4 tx = texture2D(uTexture, vec2(x, y));
        
        gl_FragColor = tx;
    }
</script>

<script id="rtt-bloomx-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    const float td = 0.005;
    
    // 5x5 Gaussian blur matrix coefficients
    const float base = 149.0;
    const float mt1 = 1.0 / base;
    const float mt4 = 4.0 / base;
    const float mt7 = 7.0 / base;
    const float mt16 = 16.0 / base;
    const float mt26 = 26.0 / base;
    const float mt41 = 41.0 / base;
    
    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        float tdx1 = 1.0 / uViewportWidth;
        float tdy1 = 1.0 / uViewportHeight;
        float tdx2 = tdx1 * 2.0;
        float tdy2 = tdy1 * 2.0;
        float tdx3 = tdx1 * 3.0;
        float tdx4 = tdx1 * 4.0;
        float tdx5 = tdx1 * 5.0;
        
        vec4 tx02 = texture2D(uTexture, vec2(x-tdx5, y)) * mt1;
        vec4 tx12 = texture2D(uTexture, vec2(x-tdx4, y)) * mt4;
        vec4 tx22 = texture2D(uTexture, vec2(x-tdx3, y)) * mt7;
        vec4 tx32 = texture2D(uTexture, vec2(x-tdx2, y)) * mt16;
        vec4 tx42 = texture2D(uTexture, vec2(x-tdx1, y)) * mt26;
        vec4 tx52 = texture2D(uTexture, vec2(x, y)) * mt41;
        vec4 tx62 = texture2D(uTexture, vec2(x+tdx1, y)) * mt26;
        vec4 tx72 = texture2D(uTexture, vec2(x+tdx2, y)) * mt16;
        vec4 tx82 = texture2D(uTexture, vec2(x+tdx3, y)) * mt7;
        vec4 tx92 = texture2D(uTexture, vec2(x+tdx4, y)) * mt4;
        vec4 txA2 = texture2D(uTexture, vec2(x+tdx5, y)) * mt1;
        
        
        gl_FragColor = tx02 + tx12 + tx22 + tx32 + tx42 + tx52 + tx62 + tx72 + tx82 + tx92 + txA2;
    }
</script>

<script id="rtt-bloomy-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    const float td = 0.005;
    
    // 5x5 Gaussian blur matrix coefficients
    const float base = 143.0;
    const float mt1 = 1.0 / base;
    const float mt4 = 4.0 / base;
    const float mt7 = 7.0 / base;
    const float mt16 = 16.0 / base;
    const float mt26 = 26.0 / base;
    const float mt41 = 41.0 / base;
    
    const float gamma = 0.8;
    
    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        float tdy1 = 1.0 / uViewportHeight;
        float tdy2 = tdy1 * 2.0;
        float tdy3 = tdy1 * 3.0;
        float tdy4 = tdy1 * 4.0;
        float tdy5 = tdy1 * 5.0;
        
        vec4 tx02 = texture2D(uTexture, vec2(x, y-tdy5)) * mt1;
        vec4 tx12 = texture2D(uTexture, vec2(x, y-tdy4)) * mt4;
        vec4 tx22 = texture2D(uTexture, vec2(x, y-tdy3)) * mt7;
        vec4 tx32 = texture2D(uTexture, vec2(x, y-tdy2)) * mt16;
        vec4 tx42 = texture2D(uTexture, vec2(x, y-tdy1)) * mt26;
        vec4 tx52 = texture2D(uTexture, vec2(x, y)) * mt41;
        vec4 tx62 = texture2D(uTexture, vec2(x, y+tdy1)) * mt26;
        vec4 tx72 = texture2D(uTexture, vec2(x, y+tdy2)) * mt16;
        vec4 tx82 = texture2D(uTexture, vec2(x, y+tdy3)) * mt7;
        vec4 tx92 = texture2D(uTexture, vec2(x, y+tdy4)) * mt4;
        vec4 txA2 = texture2D(uTexture, vec2(x, y+tdy5)) * mt1;
        
        
        gl_FragColor = tx02 + tx12 + tx22 + tx32 + tx42 + tx52 + tx62 + tx72 + tx82 + tx92 + txA2;
        
        gl_FragColor = vec4(pow(gl_FragColor.rgb, vec3(1.0 / gamma)), gl_FragColor.a);
    }
</script>

<script id="rtt-semipix-fs" type="x-shader/x-fragment">
    // Lousy pseudo pixellated look
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;

    void main(void) {
        float x = gl_FragCoord.x / uViewportWidth * uWidthDistort;
        float y = gl_FragCoord.y / uViewportHeight;
        
        vec4 tx = texture2D(uTexture, vec2(x, y));
        
        gl_FragColor = tx * 0.8;
        
        if ((mod(floor(gl_FragCoord.x), 2.0) == 1.0) || (mod(floor(gl_FragCoord.y), 2.0) == 1.0)) {
            float gamma = 1.3;
            gl_FragColor = vec4(pow(gl_FragColor.rgb, vec3(1.0 / gamma)), gl_FragColor.a);
        }
    }
</script>

<script id="rtt-2xsai-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uTexture;
    uniform float uViewportWidth;
    uniform float uViewportHeight;
    uniform float uWidthDistort;
    
// Adapted form https://github.com/libretro/common-shaders/blob/master/xsai/super-2xsai.cg
    const vec3 dtt = vec3(65536,255,1);
    
    /*  GET_RESULT function                            */
    /*  Copyright (c) 1999-2001 by Derek Liauw Kie Fa  */
    /*  License: GNU-GPL                               */
    int GET_RESULT(float A, float B, float C, float D)
    {
        int x = 0;
        int y = 0;
        int r = 0;
        
        if (A == C) {
            x+=1;
        } else if (B == C) {
            y+=1;
        }
        
        if (A == D) {
            x+=1; 
        } else if (B == D) {
            y+=1;
        }
        
        if (x <= 1) {
            r+=1; 
        }
        if (y <= 1) {
            r-=1;
        }
        
        return r;
    } 


    float reduce(vec3 color)
    { 
        return dot(color, dtt);
    }


    void main(void)
    {
        vec2 texCoord = vec2(gl_FragCoord.x / uViewportWidth * uWidthDistort, gl_FragCoord.y / uViewportHeight);
        
        // get texel size   	
        vec2 ps = vec2(0.999/ 8.0 /* font width */ / 96.0 /* console char width */ * uWidthDistort, 0.999/512.0);
        
        // calculating offsets, coordinates

        vec2 dx = vec2( ps.x, 0.0); 
        vec2 dy = vec2( 0.0, ps.y);
        vec2 g1 = vec2( ps.x,ps.y);
        vec2 g2 = vec2(-ps.x,ps.y);	
        
        vec2 pixcoord  = texCoord/ps;
        vec2 fp        = fract(pixcoord);
        vec2 pC4       = texCoord-fp*ps;
        vec2 pC8       = pC4+g1;

        

        // Reading the texels

        vec3 C0 = texture2D(uTexture,pC4-g1).xyz; 
        vec3 C1 = texture2D(uTexture,pC4-dy).xyz;
        vec3 C2 = texture2D(uTexture,pC4-g2).xyz;
        vec3 D3 = texture2D(uTexture,pC4-g2+dx).xyz;
        vec3 C3 = texture2D(uTexture,pC4-dx).xyz;
        vec3 C4 = texture2D(uTexture,pC4   ).xyz;
        vec3 C5 = texture2D(uTexture,pC4+dx).xyz;
        vec3 D4 = texture2D(uTexture,pC8-g2).xyz;
        vec3 C6 = texture2D(uTexture,pC4+g2).xyz;
        vec3 C7 = texture2D(uTexture,pC4+dy).xyz;
        vec3 C8 = texture2D(uTexture,pC4+g1).xyz;
        vec3 D5 = texture2D(uTexture,pC8+dx).xyz;
        vec3 D0 = texture2D(uTexture,pC4+g2+dy).xyz;
        vec3 D1 = texture2D(uTexture,pC8+g2).xyz;
        vec3 D2 = texture2D(uTexture,pC8+dy).xyz;
        vec3 D6 = texture2D(uTexture,pC8+g1).xyz;

        vec3 p00,p10,p01,p11;


        // reducing float3 to float
        
        float c0 = reduce(C0);float c1 = reduce(C1);
        float c2 = reduce(C2);float c3 = reduce(C3);
        float c4 = reduce(C4);float c5 = reduce(C5);
        float c6 = reduce(C6);float c7 = reduce(C7);
        float c8 = reduce(C8);float d0 = reduce(D0);
        float d1 = reduce(D1);float d2 = reduce(D2);
        float d3 = reduce(D3);float d4 = reduce(D4);
        float d5 = reduce(D5);float d6 = reduce(D6);




        /*              Super2xSaI code               */
        /*  Copied from the Dosbox source code        */
        /*  Copyright (C) 2002-2007  The DOSBox Team  */
        /*  License: GNU-GPL                          */
        /*  Adapted by guest(r) on 19.4.2007          */

         
        if (c7 == c5 && c4 != c8) {
            p11 = p01 = C7;
        } else if (c4 == c8 && c7 != c5) {
            p11 = p01 = C4;
        } else if (c4 == c8 && c7 == c5) {
            int r = 0;
            r += GET_RESULT(c5,c4,c6,d1);
            r += GET_RESULT(c5,c4,c3,c1);
            r += GET_RESULT(c5,c4,d2,d5);
            r += GET_RESULT(c5,c4,c2,d4);

            if (r > 0)
                p11 = p01 = C5;
            else if (r < 0)
                p11 = p01 = C4;
            else {
                p11 = p01 = 0.5*(C4+C5);
            }
        } else {
            if (c5 == c8 && c8 == d1 && c7 != d2 && c8 != d0)
                p11 = 0.25*(3.0*C8+C7);
            else if (c4 == c7 && c7 == d2 && d1 != c8 && c7 != d6)
                p11 = 0.25*(3.0*C7+C8);
            else
                p11 = 0.5*(C7+C8);

            if (c5 == c8 && c5 == c1 && c4 != c2 && c5 != c0)
                p01 = 0.25*(3.0*C5+C4);
            else if (c4 == c7 && c4 == c2 && c1 != c5 && c4 != d3)
                p01 = 0.25*(3.0*C4+C5);
            else
                p01 = 0.5*(C4+C5);
        }

        if (c4 == c8 && c7 != c5 && c3 == c4 && c4 != d2)
            p10 = 0.5*(C7+C4);
        else if (c4 == c6 && c5 == c4 && c3 != c7 && c4 != d0)
            p10 = 0.5*(C7+C4);
        else
            p10 = C7;

        if (c7 == c5 && c4 != c8 && c6 == c7 && c7 != c2)
            p00 = 0.5*(C7+C4);
        else if (c3 == c7 && c8 == c7 && c6 != c4 && c7 != c0)
            p00 = 0.5*(C7+C4);
        else
            p00 = C4;


        // Distributing the four products
        
        if (fp.x < 0.50)
            { if (fp.y < 0.50) p10 = p00;}
        else
            { if (fp.y < 0.50) p10 = p01; else p10 = p11;}


        // OUTPUT
        gl_FragColor = vec4(p10, 1);
    }
    ////// End of super 2xsai
</script>

<script id="default-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<div id="shaders-edit" style="position: fixed; right: 0px; bottom: 0px; width: 500px; height: 100%; background: #444; color: #fff; display: none;">
<h2>Shaders!</h2>
<h3>Fragment</h3>
<textarea id="fs-edit" rows="15" cols="60" wrap="off" style="background: #000; font-family: monospace; color #ddd;" onfocus="disableGameInput()" onblur="enableGameInput()"></textarea><br>
<h3>Vertex</h3>
<textarea id="vs-edit" rows="15" cols="60" wrap="off" style="background: #000; font-family: monospace; color #ddd;" onfocus="disableGameInput()" onblur="enableGameInput()"></textarea><br>
<button onclick="updateShaders()">Update</button>
</div>

<script src="./templates/jquery-2.1.1.min.js"></script>
<script src="./templates/ASCIITerminal.js"></script>
<script src="./templates/ascii_mapping.js"></script>
<script src="./templates/traceline.js"></script>
<script src="./templates/pako_inflate.min.js"></script>
<script src="./templates/gl-matrix.js"></script>
<script src="./templates/soundjs-0.6.2.min.js"></script>
<script src="./templates/RexSprite.js"></script>
<script>
var player = {
    isAlive: false
}
var canCheat = false
var colorMap = {
    "lava": {"color": "FF8800", "cycle": "882200", "backgroundColor": [64, 0, 0], "msscale": 4000, "luma": [5120, 5120, 5120]},
    "plasma": {"color": "FF00FF", "cycle": "880088", "backgroundColor": [64, 0, 64], "msscale": 1000, "luma": [5120, 5120, 5120]},
    "wood": {"color": "A37936"},
    "dirt": {"color": "936926"},
    "acid": {"color": "008800", "cycle": "44FF00", "msscale": 1500, "backgroundColor": [0, 64, 0], "luma": [2550, 2550, 2550]},
    "water": {"color": "0044FF", "cycle": "002288", "msscale": 2000},
    "smoke": {"color": "888888", "cycle": "444444", "msscale": 1000},
    "debris": {"color": "888888", "cycle": "444444", "msscale": 500},
    "fire": {"color": "FF0000", "cycle": "CC8800", "msscale": 200, "luma": [255, 255, 255]},
    "particle-ammo-9mm-bullets": {"color": "FF0000"},
    "particle-ammo-9mm": {"color": "FF0000"},
    "particle-ammo-12ga": {"color": "FF0000"},
    "particle-ammo-Gasoline-tank": {"color": "FF4400", "cycle": "882200", "msscale": 500},
    "blood": {"color": "FF0000", "cycle": "440000", "msscale": 2000},
    "low-level-item": {"color": "999999"},
    "low-level-ammo": {"color": "999999"},
    "mid-level-item": {"color": "CC9999"},
    "mid-level-ammo": {"color": "CC9999"},
    "high-level-ammo": {"color": "CCCC77"},
    "heal": {"color": "E00000"},
    "heal-big": {"color": "FF4494"},
    "good-weapon": {"color": "FFEB69", "cycle": "DEC628", "msscale": 1000},
    "standard-weapon": {"color": "28DE9E", "cycle": "15BD82", "msscale": 1000},
    "dangerous-weapon": {"color": "D86000", "cycle": "804000", "msscale": 1000},
    "player-shadow": {"color": "0000AA", "cycle": "000044", "msscale": 1000},
    "sound-radio": {"color": "00FF88", "cycle": "0088FF", "msscale": 1000},
    
    "health-powerup": {"color": "FF6688"},
    "armor-powerup": {"color": "FFFF66"},
    "strength-powerup": {"color": "44FF22"},
    "precision-powerup": {"color": "4444FF"},
    "speed-powerup": {"color": "68AFFF"},
    "speed-powerup-plus": {"color": "28FFFF"},
    "heal-powerup": {"color": "CC0067"},
    "heal-powerup-plus": {"color": "EC0087"},
}

var sndVolume = 0.1
var bgm

function OpenInNewTab(url) {
  var win = window.open(url, '_blank')
  win.focus()
}

function fgColorFromColorMapRule(rule, timeModifier) {
    var col = rule
    
    if ("cycle" in col) {
        var h0 = timeModifier & 0x3F
        var h1 = (timeModifier >> 6) & 0x3F
        var h16 = ((h0 | h1) ^ (timeModifier)) & 0xFFF
        
        var cycle_a = Date.now() / col.msscale + h16 / 16.0
        cycle_a -= Math.trunc(cycle_a)
        var cycle_aneg = 1.0 - cycle_a

        var col0 = hexToColor(col.color)
        var col1 = hexToColor(col.cycle)
        var r0 = ((col0 & 0x00FF0000) >> 16) & 0xFF
        var g0 = ((col0 & 0x0000FF00) >> 8) & 0xFF
        var b0 = ((col0 & 0x000000FF)) & 0xFF
        
        var r1 = ((col1 & 0x00FF0000) >> 16) & 0xFF
        var g1 = ((col1 & 0x0000FF00) >> 8) & 0xFF
        var b1 = ((col1 & 0x000000FF)) & 0xFF
        
        var rt = r0 * cycle_aneg + r1 * cycle_a
        var gt = g0 * cycle_aneg + g1 * cycle_a
        var bt = b0 * cycle_aneg + b1 * cycle_a
        
        return [rt, gt, bt]
    } else {
        return col.color
    }
}

var ownUsername
var displaySizeX = 64
var displaySizeY = 64
var turn = 0
var minCoords = {x: 0, y: 0}
var particles
var gameStarted = false
var terminal
var showDamage = 0
var useSounds = true
var playerAttrs
var displaySuPow
var titleSprite
var gplusSprite
var twitterSprite
var redditSprite
var lighthouseSprite
var ganymedeSprite
var menuSel = 0
var currentMenu = 0
var lastClick = [-1, -1]
var lastMove = [-1, -1]
var keyboardLook = false
var onClickTarget
var destinationMovement
var tutorialSeen = false
var tutorialPage = 0

var inspectKeyboardIndex = -1
var inspectKeyboardIdentifier = ""

var weaponSprites = {}

var keybindingsMenuIdentifier = ["Left", "Right", "Up", "Down", "UpLeft", "DownLeft", "UpRight", 
            "DownRight", "Wait", "Inventory", "Fire", "Reload", "View", "Grab", "SuperPow", "Activate", 
            "Prone", "Crouch"]
var keyBindingNames = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
            
var playerClasses = [
        {id: "marine", name: "Marine", description: "Most versatile class, without too much bonuses"},
        {id: "heavy", name: "Heavy Weapons", description: "Has bonuses on chainguns and rocket launchers"},
        {id: "swords", name: "Swordmaster", description: "Masters all knife-like weapons, from a butter knife to a lightsaber"},
        {id: "melee", name: "Melee", description: "Pipes, bats, power-fists and bare fists. Everything that's close up and personal is best suited for this one"},
        {id: "tech", name: "Technician", description: "Can repair doors and computers"},
        {id: "engy", name: "Engineer", description: "Can hack computers and robots"},
        {id: "medic", name: "Medic", description: "Can heal nearby party members"},
        {id: "spy", name: "Spy", description: "Disappears when not moving for 3 turns"},
        {id: "explo", name: "Explosives", description: "Can arm/disarm bombs, mines and explosive traps"},
        {id: "sniper", name: "Sniper", description: "Can see farther than any class and has natural precision"},
        {id: "psychic", name: "Psychic", description: "Can resist psychic attacks and in some cases, control enemies"},
        {id: "civil", name: "Civilian", description: "Hardest, craziest way to play the game"},
    ]
var itemsPerMenu = [(typeof(require) !== "undefined")?5:4, playerClasses.length + 2, 6, 1, 3, 20]
var menuOptionsNumber = itemsPerMenu[0]

var level = []
var levelTileset = ""

var tilesetDescription = {
    "base": {
        24: "Lever",
        233: "Barrel",
        61: "Closed door",
        95: "Open door",
        62: "Downstairs"
    },
    "lava": {
        24: "Lever",
        233: "Barrel",
        61: "Closed door",
        95: "Open door",
        62: "Downstairs"
    },
    "cave": {
        24: "Lever",
        233: "Barrel",
        61: "Closed door",
        95: "Open door",
        62: "Downstairs"
    }
}

var tilePixActions = {
    24: "Activate",
    61: "Open door",
    95: "Close door",
    62: "Exit level"
}

var cssRules = {}

var playerDivs = {}

var queuedAnns = []
var queuedInterval = null
var playerPickClass = "marine"
var currentTips = []
var clearTipsTimeout = null
var showingInventory = false
var inventoryIndex = 0
var inventoryList
var opsColsFg = {true: [0, 255, 0], false: [64, 96, 64]}
var opsColsBg = {true: [64, 64, 128], false: [32, 32, 32]}
var opsColsLuma = {true: [255, 255, 255], false: [16, 16, 16]}
var menuStars = []

var announcements = []

var descriptions = []
var actionMenuShown = false
var actionMenuCenter = [0, 0]
var actionMenuActions

var currentPkts = []

function queueAnnouncements(msgs) {
    announcements = announcements.concat(msgs)
}

function announceMsg(msg) {
    announcements.push(msg)
}

function pickClass(cls) {
    playerPickClass = cls
}

function start() {
    descriptions = []
    displaySuPow = 0
    
    localStorage.username = ownUsername
    localStorage.chartype = playerPickClass
    
    if (bgm) {
        bgm.stop()
    }
    
    send({
        type: 'start',
        username: ownUsername,
        player_class: playerPickClass
    })
    
    return false
}

function pos(ndx, ndy, shifted) {
    descriptions = []
    
    var npos = {x: player.pos.x, y: player.pos.y}
    if (typeof(ndx) != 'undefined') {
        npos.x += ndx
    }
    
    if (typeof(ndy) != 'undefined') {
        npos.y += ndy
    }
    
    send({
        type: 'pos',
        pos: npos,
        special: shifted
    })
}

function describe(x, y) {
    /*send ({
        type: 'describe',
        pos: {x: x, y: y}
    })*/
    var desc = {}
    
    descriptions = []
    
    if ((y >= 0) && (y < level.length)) {
        var row = level[y]
        
        if ((x >= 0) && (x < row.length)) {
            var tile = row[x]
            
            var description = []
            
            if (tile.turn != turn) {
                description.push({text: "You saw:"})
            } else {
                description.push({text: "You see:"})
            }
            
            if ("character" in tile) {
                if (("type" in tile.character) && (tile.character.type == 'ai')) {
                    if (tile.character.username) {
                        description.push({text: (/(.*)N.*/).exec(tile.character.username).pop().trim()})
                    } else {
                        description.push({text: "Unnamed enemy"})
                    }
                } else {
                    if ((x == player.pos.x) && (y == player.pos.y)) {
                        description.push({text: "Yourself"})
                    } else if (!tile.character.username) {
                        description.push({text: "Player " + tile.character.username})
                    } else {
                        description.push({text: "A Player"})
                    }
                }
                
                if ("color" in tile.character) {
                    description[description.length-1].fg = tile.character.color
                }
            }
            
            if ("item" in tile) {
                if ("name" in tile.item) {
                    description.push({text: tile.item.name})
                } else if ("ammoType" in tile.item) {
                    description.push({text: tile.item.ammoType + " charger"})
                }
                
                if ("cssClass" in tile.item) {
                    description[description.length-1].cssClass = tile.item.cssClass
                }
            }
            
            if ("debris" in tile) {
                if ("type" in tile.debris) {
                    description.push({text: tile.debris.type})
                }
                
                if ("color" in tile.debris) {
                    description[description.length-1].fg = tile.debris.color
                }
            }
            
            var hazardDescribed = false
            if ("cssClass" in tile) {
                if (tile.cssClass == "acid") {
                    hazardDescribed = true
                    description.push({text: "Acid", cssClass: "acid"})
                } else if (tile.cssClass == "lava") {
                    hazardDescribed = true
                    description.push({text: "Lava", cssClass: "lava"})
                } else if (tile.cssClass == "plasma") {
                    hazardDescribed = true
                    description.push({text: "Plasma", cssClass: "plasma"})
                }
            }
            
            if (!hazardDescribed && ("damage" in tile)) {
                description.push({text: "Hazardous floor", cssClass: "lava"})
            }
            
            if (levelTileset in tilesetDescription) {
                var thisTilesetDescriptor = tilesetDescription[levelTileset]
                
                if (tile.tile in thisTilesetDescriptor) {
                    var specificTileDescriptor = thisTilesetDescriptor[tile.tile]
                    var fgbgdesc = tile.fg + "-" + tile.bg
                    
                    if (typeof(specificTileDescriptor[fgbgdesc]) != "undefined") {
                        description.push({text: specificTileDescriptor[fgbgdesc]})
                    } else if (typeof(specificTileDescriptor[tile.fg]) != "undefined") {
                        description.push({text: specificTileDescriptor[tile.fg]})
                    } else if (typeof(specificTileDescriptor[tile.bg]) != "undefined") {
                        description.push({text: specificTileDescriptor[tile.bg]})
                    } else if (typeof(specificTileDescriptor["default"]) != "undefined") {
                        description.push({text: specificTileDescriptor["default"]})
                    } else {
                        description.push({text: specificTileDescriptor})
                    }
                }
            }
            
            //console.log(tile)
            //console.log(descriptions)
            
            desc.pos = [lastMove[0], lastMove[1] - description.length - 1]
            desc.lines = description
            
            descriptions.push(desc)
        }
    }
}

function prone() {
    descriptions = []
    
	send({
        type: 'prone'
    })
}

function crouch() {
    descriptions = []
    
	send({
        type: 'crouch'
    })
}

var expectedPlayerPos
var onReachCallback
function tryMoveTowardsDestination() {
    descriptions = []
    
    if ((destinationMovement != undefined)&&
        ((expectedPlayerPos == undefined)||
         ((expectedPlayerPos[0] == player.pos.x)&&
          (expectedPlayerPos[1] == player.pos.y)) ) ) {
        var dx = 0, dy = 0
        
        if (player.pos.x < destinationMovement[0]) {
            dx = 1
        } else if (player.pos.x > destinationMovement[0]) {
            dx = -1
        }
        
        if (player.pos.y < destinationMovement[1]) {
            dy = 1
        } else if (player.pos.y > destinationMovement[1]) {
            dy = -1
        }
        
        if ((dx != 0) || (dy != 0)) {
            expectedPlayerPos = [player.pos.x + dx, player.pos.y + dy]
            pos(dx, dy)
        } else {
            destinationMovement = undefined
            delete expectedPlayerPos
            
            if (onReachCallback) {
                onReachCallback()
                onReachCallback = undefined
            }
        }
    } else {
        expectedPlayerPos = undefined
        destinationMovement = undefined
    }
}

function activateMenuAction(i) {
    actionMenuShown = false
    lastClick = [-1, -1]
    
    if (mouseActions[actionMenuActions[i].text]) {
        var pos = actionMenuActions[i].pos || {x: -1, y: -1} // A good fallback to avoid unnecessary logic
        mouseActions[actionMenuActions[i].text](pos.x, pos.y, actionMenuActions[i])
    }
}

function use() {
    descriptions = []
    
    if (gameStarted) {
        if (showingInventory) {
            if ((actionMenuShown) && (actionMenuActions) && (menuSel >= 0) && (menuSel < actionMenuActions.length)) {
                // Activate the option
                activateMenuAction(menuSel)
            } else {
                activateInventory(inventoryIndex)
            }
        } else if (keyboardLook) {
            if ((typeof(onClickTarget) != "undefined") && (onClickTarget != null)) {
                var x = player.pos.x + (lastMove[0] - player.cpos.x)
                var y = player.pos.y + (lastMove[1] - player.cpos.y)
                onClickTarget(x, y, true)
            } else {
                menuSel = -1
                clickCell(lastMove[0], lastMove[1])
            }
            
            shutdownKeyboardLook()
        } else if ((actionMenuShown) && (actionMenuActions) && (menuSel >= 0) && (menuSel < actionMenuActions.length)) {
            // Activate the option
            activateMenuAction(menuSel)
        } else {
            send({
                type: 'use'
            })
        }
    } else {
        menuUse()
    }
}

function useInventory(idx) {
    send({
        type: 'useInventory',
        index: idx
    })
}

function drop(idx) {
    send({
        type: 'dropInventory',
        index: idx
    })
}

function unload(idx) {
    send({
        type: 'unloadInventory',
        index: idx
    })
}

function inspect(idx) {
    send({
        type: 'inspectInventory',
        index: idx
    })
}

function grab() {
    descriptions = []
    
    send({
        type: 'grab'
    })
}

function fire(alternate, pos) {
    var ret
    descriptions = []
    
    if (alternate && ((typeof(player.firing) == "undefined") || (player.firing != 'alternate'))) {
        player.firing = 'alternate'
    } else if ((typeof(player.firing) == "undefined") || (player.firing != 'primary')) {
        player.firing = 'primary'
    }
    
    var fireFunc = function(x, y) {
        send({
            type: 'fire',
            tgt: {x: x, y: y},
            alt: alternate
            })
            
        shutdownKeyboardLook()
    }
    
    if (!pos) {
        var didntHaveLook = !keyboardLook
        waitTarget(fireFunc)
        
        if (didntHaveLook) {
            fnCommands.toggleKeyboardLook()
        }
        ret = "cursor"
        announceMsg("Click over a cell to target")
        
        var ntgt = nearestTarget()
        
        if (typeof(ntgt) !== "undefined") {
            lastMove = [ntgt.x, ntgt.y]
        }
        
    } else {
        fireFunc(pos.x, pos.y)
        player.firing = 'no'
        
        shutdownKeyboardLook()
    }
    
    return ret
}

function superPower(alternate) {
    send({
        type: 'supow',
        alt: alternate
        })
}

function cheat(fn, data) {
    var msg = {
        type: 'cheat',
        fn: fn
    }
    if (data) {
        msg.data = data
    }
    send(msg)
}

function reload(alternate) {
    descriptions = []
    
    send({
        type: 'reload',
		alt: alternate
    })
}

function updateInventory() {
    descriptions = []
    
    send({
        type: 'inventory'
    })
}

function activateInventory(idx) {
    descriptions = []

    var actions = []
    
    actions.push({"text": "Use"})
    actions.push({"text": "Drop"})
    actions.push({"text": "Unload"})
    actions.push({"text": "Inspect"})
    actions.push({"text": "Close", "bg": {true: [192, 64, 64], false: [48, 0, 0]}})
    actionMenuShown = true
    actionMenuActions = actions
    actionMenuCenter = lastClick
}

function clearTips() {
    descriptions = []
}

function showTips() {
    if (clearTipsTimeout != null) {
        clearTimeout(clearTipsTimeout)
        clearTips()
        return
    }


    // First, collect all the "tippable" entities
    // TODO: The items should be classified if they are on sight or not
    var tip_items = []
    for (var y=0; y < displaySizeY; y++) {
        var row = level[y + minCoords.y]
        for (var x=0; x < displaySizeX; x++) {
            var tile = row[x + minCoords.x]
            
            if (tile.character || tile.item) {
                var o = absolutePosToWindow(x + minCoords.x, y + minCoords.y)
                o.tile = tile
                tip_items.push(o)
            }
        }
    }
    
    // TODO: Check that the boxes don't collide!
    var bod = $(document.body)
    for (var i=0; i < tip_items.length; i++) {
        var o = tip_items[i]
        var tip = $("<div>")
        if ((typeof(o.tile.character) != "undefined") && (o.tile.character != null)) {
            tip.text(o.tile.character.username)
        }
        
        if ((typeof(o.tile.item) != "undefined") && (o.tile.item != null)) {
            tip.text(o.tile.item.name || o.tile.item.ammoType)
        }
        
        tip.css('position', 'fixed')
        tip.addClass('tip')
        o.left += 16
        tip.offset(o)
        bod.append(tip)
        currentTips.push(tip)
    }
    
    clearTipsTimeout = setTimeout(clearTips, 1000)
}

function toggleInventory() {
    descriptions = []
    actionMenuShown = false
    lastClick = [-1, -1]
    
    if (showingInventory) {
        showingInventory = false
    } else {
        updateInventory()
        showingInventory = true
    }
}

function drawInventory() {
    drawAsciiText(1, 0, 'Inventory', [0, 255, 0], [0, 0, 0])
    if (inventoryList) {
        inventoryIndex = Math.min(Math.max(0, inventoryIndex), inventoryList.length - 1)
        
        if (!actionMenuShown && (lastMove[1] >= 2) && (lastMove[0] >= 1) && (lastMove[0] < 64)) {
            var ni = Math.floor((lastMove[1] - 2)/2)
            
            if (ni < 0) {
                ni = -1
            } else if (ni >= inventoryList.length) {
                ni = -1
            }
            
            inventoryIndex = ni
        }
        
        for (var i=0; i < inventoryList.length; i++) {
            var item = inventoryList[i]
            var txt = ''
            var fgcol = [0, 0, 0]
            
            if (item.type == 'ammo') {
                txt = item.ammoType + ' (' + item.amount + ') x' + item.minDamageMult + '-' + item.maxDamageMult
                fgcol = [153, 153, 0]
            } else if (item.type == 'weapon') {
                txt = item.name + ' dmg: ' + item.damage[0] + '-' + item.damage[1] + ' (' + item.ammoType + ' ' + item.ammo + '/' + item.ammoMax+ ')'
                fgcol = [221, 0, 0]
            } else {
                txt = item.name
                fgcol = [64, 192, 0]
            }
            
            drawAsciiText(1, 2 + i * 2, txt, fgcol, opsColsBg[i == inventoryIndex])
            
            if (!actionMenuShown && (lastClick[0] != -1) && (lastClick[1] != -1) &&
                (lastClick[0] == lastMove[0]) && (lastClick[1] == lastMove[1])&&
                (inventoryIndex == i)) {
                use()
                lastClick = [-1, -1]
            }
        }
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 24, displaySizeY - 4, "Close", 16, opsColsFg, opsColsBg, 0)) {
        showingInventory = false
        actionMenuShown = false
    }
}

function cancelTarget() {
    onClickTarget = undefined
    player.firing = 'no'
}

function nearestTarget() {
    var sightFov = player.fov
    var sf2 = sightFov * sightFov
    var foundTarget = false
    var lightThreshold = 96
    var selx, sely, seld2 = sf2*2
    
    for (var y=-sightFov; y < sightFov; y++) {
        var ty = player.pos.y + y
        
        if ((ty >= 0) && (ty < level.length)) {
            var yy = y*y
            for (var x=-sightFov; x < sightFov; x++) {
                var tx = player.pos.x + x
                if ((tx >= 0) && (tx < level[0].length)) {
                    var d2 = x*x + yy
                    
                    if ((d2 <= sf2) && (d2 != 0)) {
                        var tile = level[ty][tx]
                        
                        if (tile.character && (tile.turn == turn)) {
                            // TODO: Check the character is aggresive to us
                            
                            var newFoundLight = Math.max(tile.light.color[0], tile.light.color[1], tile.light.color[2])
                            
                            if ((d2 < seld2) && (newFoundLight > lightThreshold)) {
                                selx = tx
                                sely = ty
                                seld2 = d2
                                foundTarget = true
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (foundTarget) {
        return {x: selx - player.pos.x + player.cpos.x, y: sely - player.pos.y + player.cpos.y}
    }
}

function waitTarget(fn) {
    if (onClickTarget) {
        // Autoselect target
        var sightFov = player.fov
        var sf2 = sightFov * sightFov
        var foundTarget = false
        var selx, sely, seld2 = sf2*2
        
        for (var y=-sightFov; y < sightFov; y++) {
            var ty = player.pos.y + y
            
            if ((ty >= 0) && (ty < level.length)) {
                var yy = y*y
                for (var x=-sightFov; x < sightFov; x++) {
                    var tx = player.pos.x + x
                    if ((tx >= 0) && (tx < level[0].length)) {
                        var d2 = x*x + yy
                        
                        if ((d2 <= sf2) && (d2 != 0)) {
                            var tile = level[ty][tx]
                            
                            if (tile.character) {
                                // TODO: Check the character is aggresive to us
                                if (d2 < seld2) {
                                    selx = tx
                                    sely = ty
                                    seld2 = d2
                                    foundTarget = true
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if (foundTarget) {
            onClickTarget(selx, sely, true)
            player.firing = "no"
        }
        shutdownKeyboardLook()
    } else {
        // Wait target selection
        onClickTarget = function(x, y, direct) {
            // Correct x and y relative to the player position display
            if (!direct && player.cpos) {
                x = player.pos.x + (x - player.cpos.x)
                y = player.pos.y + (y - player.cpos.y)
            }
            fn(x, y)
            onClickTarget = null
            shutdownKeyboardLook()
            player.firing = "no"
        }
    }
}

function moveToDest(x, y, reachCallback) {
    descriptions = []
    
    if (player.cpos) {
        var x = player.pos.x + (x - player.cpos.x)
        var y = player.pos.y + (y - player.cpos.y)
        
        destinationMovement = [x, y]
        
        onReachCallback = reachCallback
        tryMoveTowardsDestination()
    }
}

function clickCell(x, y) {
    lastClick = [x, y]
    if (showingInventory) {
    } else if (gameStarted) {
        if ((typeof(onClickTarget) != "undefined")&&(onClickTarget != null)) {
            onClickTarget(x, y)
        } else if (gameStarted && (x < displaySizeX)) {
            if (actionMenuShown) {
                //actionMenuShown = false
            } else {
                var tx = player.pos.x + (x - player.cpos.x)
                var ty = player.pos.y + (y - player.cpos.y)
                
                if ((ty >= 0) && (ty < level.length)) {
                    var row = level[ty]
                    
                    if ((tx >= 0) && (tx < row.length)) {
                        var tile = row[tx]
                        var actions = []
                        
                        console.log(tile)
                        
                        if ("character" in tile) {
                            // TODO Check if the character is friend or foe
                            var dx = Math.abs(player.cpos.x - x)
                            var dy = Math.abs(player.cpos.y - y)
                            var meleeDistance = (dx <= 1) && (dy <= 1)

                            if ((dx == 0) && (dy == 0)) {
                                // The player itself
                                actions.push({"text": "Show inventory", "pos": {x: x, y: y}})
                                
                                actions.push({"text": "Wait", "pos": {x: x, y: y}})
                                
                                if (currentWeapon.ranged && (currentWeapon.ammo < currentWeapon.ammoMax)) {
                                    actions.push({"text": "Reload", "pos": {x: x, y: y}})
                                }
                                
                                if (currentWeapon.ranged && currentWeapon.alternate && (currentWeapon.alternate.ammo < currentWeapon.alternate.ammoMax)) {
                                    actions.push({"text": "Reload alternate", "pos": {x: x, y: y}})
                                }
                                
                                if (player.crouch  || player.prone) {
                                    actions.push({"text": "Stand", "pos": {x: x, y: y}})
                                }
                                
                                if (!player.crouch) {
                                    actions.push({"text": "Crouch", "pos": {x: x, y: y}})
                                }
                                
                                if (!player.prone) {
                                    actions.push({"text": "Prone", "pos": {x: x, y: y}})
                                }
                                
                                if (canCheat) {
                                    actions.push({"text": "God mode", "bg": {true: [64, 64, 192], false: [0, 0, 192]}})
                                }
                                
                            } else {
                                if (meleeDistance) {
                                    actions.push({"text": "Attack (melee)", "pos": {x: x, y: y}})
                                    
                                    if (!currentWeapon.ranged && currentWeapon.alternate) {
                                        actions.push({"text": "Attack (melee, alternate)", "pos": {x: x, y: y}})
                                    }
                                }
                                
                                if (currentWeapon.ranged) {
                                    actions.push({"text": "Attack (ranged)", "pos": {x: x, y: y}})
                                }
                                
                                if (currentWeapon.ranged && currentWeapon.alternate) {
                                    actions.push({"text": "Attack (ranged, alternate)", "pos": {x: x, y: y}})
                                }
                                
                                if (canCheat) {
                                    actions.push({"text": "Inspect FSM", "pos": {x: x, y: y}, "bg": {true: [64, 64, 192], false: [0, 0, 192]}})
                                }
                            }
                        }
                        
                        if ("item" in tile) {
                            actions.push({"text": "Walk here", "pos": {x: x, y: y}})
                            actions.push({"text": "Grab", "pos": {x: x, y: y}})
                        }
                        
                        if (tile.tile in tilePixActions) {
                            actions.push({"text": "Walk here", "pos": {x: x, y: y}})
                            actions.push({"text": tilePixActions[tile.tile], "pos": {x: x, y: y}})
                        }
                        
                        if (actions.length > 0) {
                            actions.push({"text": "Close", "bg": {true: [192, 64, 64], false: [48, 0, 0]}})
                            actionMenuShown = true
                            actionMenuActions = actions
                            actionMenuCenter = [x, y]
                        } else {
                            moveToDest(x, y)
                        }
                    }
                }
            }
        }
    }
}

function moveCell(x, y) {
    lastMove = [x, y]

    if (("pos" in player) && ("cpos" in player)) {
        var x = player.pos.x + (x - player.cpos.x)
        var y = player.pos.y + (y - player.cpos.y)
        
        describe(x, y)
    }
}

function updateWeapon(w) {
    if (typeof(w) != "undefined") {
        currentWeapon = w
     }
}

function randomColorBetween(c0, c1) {
    var a = Math.random()
    var a1 = 1 - a
    
    c0 = hexToColor(c0)
    c1 = hexToColor(c1)
    
    var r0 = ((c0 & 0x00FF0000) >> 16) & 0xFF
    var g0 = ((c0 & 0x0000FF00) >> 8) & 0xFF
    var b0 = ((c0 & 0x000000FF)) & 0xFF
    
    var r1 = ((c1 & 0x00FF0000) >> 16) & 0xFF
    var g1 = ((c1 & 0x0000FF00) >> 8) & 0xFF
    var b1 = ((c1 & 0x000000FF)) & 0xFF
    
    return [
        Math.floor(a * r0 + a1 * r1),
        Math.floor(a * g0 + a1 * g1),
        Math.floor(a * b0 + a1 * b1),
    ]
}

function spawnTrail(tr, x, y) {
    if (tr) {
        var cell = level[y][x]
        var num = 1 + Math.random() * tr.num
        var part = {}
        
        for (var i=0; i < num; i++) {
            part.route = TraceLine(x, y, 
                Math.round(x + (Math.random() * tr.spread[0]) - tr.spread[0]/2),
                Math.round(y + (Math.random() * tr.spread[1]) - tr.spread[1]/2)).reverse()
            part.routeStart = Date.now() + tr.delay * Math.random()
            part.timeGranule = (tr.ttl * Math.random()) / (part.route.length + 1)
            part.bg = randomColorBetween(tr.from, tr.to)
            part.fg = [0,0,0]
            part.pix = 0
            part.cssClass = ''
            part.trail = false
            
            cell.particles.push(part)
        }
    }
}

function updateDisplay() {
    if (gameStarted) {
        updateDisplayGameStarted()
    } else if (currentMenu == 0) {
        updateDisplayMenu()
    } else if (currentMenu == 1) {
        // Char select
        updateCharMenu()
    } else if (currentMenu == 2) {
        // Options
        updateOptionsMenu()
    } else if (currentMenu == 3) {
        // Contact
        //updateFundraiserMenu()
        updateContactMenu()
    } else if (currentMenu == 4) {
        // Tutorial
        updateTutorial()
    } else if (currentMenu == 5) {
        // Tutorial
        updateKeybindings()
    }
    
    terminal.setPixelBg(lastMove[0], lastMove[1], 
        [Math.round(((Date.now() / 200.0) % 1 - 0.5) * 128 + 128),
         Math.round(((Date.now() / 400.0) % 1 - 0.5) * 128 + 32), 
         Math.round(((Date.now() / 100.0) % 1 - 0.5) * 32 + 64)])
}

function aberrateColor(col) {
    if (Math.random() < 0.3) {
        return [
            col[0] + Math.floor(Math.random() * 64),
            col[1] + Math.floor(Math.random() * 64),
            col[2] + Math.floor(Math.random() * 64)
        ]
    } else {
        return col
    }
}

function drawButtonWithText(x, y, txt, width, fg, bg, menuOp) {
    var vpadtxt = Array(width + 1).join(" ")
    var dw = width - txt.length
    var lpad = Math.ceil(dw / 2) + 1
    var rpad = Math.floor(dw / 2) + 1
    
    var luma = (menuSel == menuOp)?[255,255,255]:[0,0,0]
    
    var moveWithinBounds = (lastMove[0] >= x)&&(lastMove[0] <= (x + width))&&(lastMove[1] >= y)&&(lastMove[1] < (y + 3))
    
    if (!Array.isArray(fg)) {
        fg = fg[moveWithinBounds]
    }
    
    if (!Array.isArray(bg)) {
        bg = bg[moveWithinBounds]
    }
    
    drawAsciiText(x, y, vpadtxt, fg, bg, luma)
    drawAsciiText(x, y + 1, Array(lpad).join(" ") + txt + Array(rpad).join(" "), fg, bg, luma)
    drawAsciiText(x, y + 2, vpadtxt, fg, bg, luma)
    
    if ((lastClick[0] >= x)&&(lastClick[0] <= (x + width))&&
        (lastClick[1] >= y)&&(lastClick[1] < (y + 3))) {
        return true
    } else {
        if (moveWithinBounds) {
            if ((menuSel != menuOp)&&(editMode)) {
                finishEditText()
            }
            menuSel = menuOp
        }
        return false
    }
}

function drawEditWithHint(x, y, txt, hint, width, fg, bg, menuOp) {
    var vpadtxt = Array(width + 1).join(" ")
    
    if (!txt || txt.length == 0) {
        txt = hint
    }
    
    var dw = width - txt.length
    var lpad = Math.max(1, Math.ceil(dw / 2) + 1)
    var rpad = Math.max(1, Math.floor(dw / 2) + 1)
    
    drawAsciiText(x, y, vpadtxt, fg, bg)
    drawAsciiText(x, y + 1, Array(lpad).join(" ") + txt + Array(rpad).join(" "), fg, bg)
    drawAsciiText(x, y + 2, vpadtxt, fg, bg)
    
    if ((lastClick[0] >= x)&&(lastClick[0] <= (x + width))&&
        (lastClick[1] >= y)&&(lastClick[1] < (y + 3))) {
        return true
    } else {
        if ((lastMove[0] >= x)&&(lastMove[0] <= (x + width))&&
            (lastMove[1] >= y)&&(lastMove[1] < (y + 3))) {
            if ((menuSel != menuOp)&&(editMode)) {
                finishEditText()
            }
            menuSel = menuOp
        }
        return false
    }
}

var editMode = false
var editModeSingleLine = true
var editCallback
var editText
var editCursorPos
var cursorBlinkInterval
function beginEditText(txt, cb) {
    editMode = true
    if (txt) {
        editText = txt
        editCursorPos = txt.length
    } else {
        editText = ""
        editCursorPos = 0
    }
    
    var nb = 0
    cursorBlinkInterval = setInterval(function() {
        if (editText.length > 0) {
            if ((nb % 3) == 0) {
                cb(editText.slice(0, editCursorPos-1) + '_' + editText.slice(editCursorPos))
            } else {
                cb(editText)
            }
        }
        
        nb += 1
    }, 200)
    
    editCallback = function(key) {
        var finished = false
        if (key == 8) {
            if (editCursorPos >= editText.length) {
                editText = editText.slice(0, editText.length - 1)
            } else {
                editText = editText.slice(0, editCursorPos-1) + editText.slice(editCursorPos)
            }
            editCursorPos -= 1
        } else if (key == 37) {
            editCursorPos = Math.max(0, editCursorPos-1)
        } else if (key == 39) {
            editCursorPos = Math.min(editText.length, editCursorPos+1)
        } else if (key == 13) {
            finishEditText()
            finished = true
        } else {
            if (editCursorPos >= editText.length) {
                editText += String.fromCharCode(key)
            } else {
                editText = editText.slice(0, editCursorPos-2) + String.fromCharCode(key) + editText.slice(editCursorPos-1)
            }
            editCursorPos += 1
        }
        
        cb(editText, finished)
    }
}

function finishEditText() {
    clearInterval(cursorBlinkInterval)
    if (typeof(editCallback) !== "undefined") {
        editCallback(39)
    }
    editMode = false
}

function drawButtonWithCheckAndText(x, y, txt, width, checked, fg, bg, menuOp) {
    var vpadtxt = Array(width + 1).join(" ")
    var dw = width - txt.length
    var lpad = Math.ceil(dw / 2) + 1
    var rpad = Math.floor(dw / 2) + 1
    drawAsciiText(x, y, vpadtxt, fg, bg)
    drawAsciiText(x, y + 1, Array(lpad).join(" ") + txt + Array(rpad).join(" "), fg, bg)
    
    terminal.setPixel(x + 1, y + 1, checked?254:255, fg, bg)
    
    drawAsciiText(x, y + 2, vpadtxt, fg, bg)
    
    if ((lastClick[0] >= x)&&(lastClick[0] <= (x + width))&&
        (lastClick[1] >= y)&&(lastClick[1] < (y + 3))) {
        return true
    } else {
        if ((lastMove[0] >= x)&&(lastMove[0] <= (x + width))&&
            (lastMove[1] >= y)&&(lastMove[1] < (y + 3))) {
            if ((menuSel != menuOp)&&(editMode)) {
                finishEditText()
            }
            menuSel = menuOp
        }
        
        return false
    }
}

function drawStarsAndGanymede() {
    if (menuStars.length == 0) {
        var cols = [[140, 140, 140], [120, 120, 120], [70, 70, 70], [32, 32, 32]]
        var pixis = [46, 7, 42, 15, 21, 233]
        for (var i=0; i < 100; i++) {
            var p = Math.floor(Math.random() * 4) + 1
            var rpix = Math.random() * p/3
            menuStars.push({
                dv: p,
                col: aberrateColor(cols[p-1]),
                y: Math.floor(Math.random() * displaySizeY),
                pix: pixis[Math.floor(rpix * rpix * pixis.length)],
                phase: Math.random()
            })
        }
    }
    
    var d = Date.now()
    
    for (var i=0; i < menuStars.length; i++) {
        var star = menuStars[i]
        var tg = ((d / (32000.0 * star.dv) + star.phase) % 1)
        var px = Math.floor(tg * (displaySizeX + 64) - 32)
        var py = Math.floor( -tg * 8 + star.y - 4)
        terminal.setPixel(px, py, star.pix, star.col, undefined, [255, 255, 255])
    }
    
    if (ganymedeSprite) {
        var tg = ((d / 24000.0) % 1)
        var px = Math.floor( tg * (displaySizeX + 64) - 32)
        var py = Math.floor( -tg * (displaySizeY / 2) + displaySizeY / 4 * 2)
        drawRexSprite(px, py, ganymedeSprite)
    }
}

function updateDisplayMenu() {
    terminal.clear()
    
    drawStarsAndGanymede()
    
    if (titleSprite) {
        drawRexSprite(Math.floor((displaySizeX + 32)/2) - 20, 0, titleSprite)
    }
        
    if (tutorialSeen) {
        if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 21, "Start", 12, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
            menuUse(0)
        }
    } else {
        if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 21, "Tutorial", 12, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
            menuUse(0)
        }
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 25, "Options", 12, opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 29, "Contact", 12, opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
    
    if (tutorialSeen) {
        if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 33, "Tutorial", 12, opsColsFg[menuSel == 3], opsColsBg[menuSel == 3], 3)) {
            menuUse(3)
        }
    } else {
        if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 33, "Start", 12, opsColsFg[menuSel == 3], opsColsBg[menuSel == 3], 3)) {
            menuUse(3)
        }
    }
    
    if (typeof(require) !== "undefined") {
        var exbg = {true: [192, 64, 64], false: [48, 0, 0]}
        var exfg = {true: [192, 192, 64], false: [48, 48, 0]}
        if (drawButtonWithText(((displaySizeX + 32)/2) - 6, 38, "Exit Game", 12, exfg[menuSel == 4], exbg[menuSel == 4], 4)) {
            menuUse(4)
        }
    }
    
   
    /*for (var i=0; i < 256; i++) {
        terminal.setPixel(i % 16, Math.floor(i / 16), i, [255, 255, 255], [0, 0, 0])
    }*/
    
    drawAsciiText(0, displaySizeY-1, "Developed by ViciousRobotRodent.com - @johnvillarz - 2015", [128, 128, 128])
}

var charSprites = {}
function updateCharMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    drawAsciiText(1, 1, "Pick your class", [192, 255, 192])
    
    for (var i=0; i < playerClasses.length; i++) {
        var selected = menuSel == i
        var name = playerClasses[i].name
        var id = playerClasses[i].id
        var description = playerClasses[i].description
        
        if (drawButtonWithText(1, 3 + i * 3, name, 16, opsColsFg[selected], opsColsBg[selected], i)) {
            if (menuSel == i) {
                menuUse(i)
            } else {
                menuSel = i
                lastClick = [-1, -1]
            }
        }
        
        if (selected) {
            if (id in charSprites) {
                if (charSprites[id] != null) {
                    drawRexSprite(18, 3, charSprites[id])
                }
            } else {
                charSprites[id] = null
                
                var f = function(sid) {
                    loadXpSprite("char" + sid, function(sp) { charSprites[sid] = sp })
                }
                f(id)
            }
            
            drawAsciiText(18, 27, description, [224, 244, 244], [0,0,0], [0,0,0])
        }
    }
    
    if (drawEditWithHint(((displaySizeX + 32)/2) - 16, displaySizeY - 10, ownUsername, "Player's name", 32, opsColsFg[menuSel == playerClasses.length], opsColsBg[menuSel == playerClasses.length], playerClasses.length)) {
        menuUse(playerClasses.length)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == playerClasses.length+1], opsColsBg[menuSel == playerClasses.length+1], playerClasses.length+1)) {
        menuUse(playerClasses.length+1)
    }
}

function updateOptionsMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    if (drawButtonWithCheckAndText(((displaySizeX + 32)/2) - 16, 21, "Duplicate console size", 32, localStorage.dupConSz == "true", opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
    
    if (drawButtonWithCheckAndText(((displaySizeX + 32)/2) - 16, 25, "Use 2xSAI shader", 32, localStorage.use2xsai == "true", opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }
    
    if (drawButtonWithCheckAndText(((displaySizeX + 32)/2) - 16, 29, "Use Music", 32, localStorage.useMusic == "true", opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
    
    if (drawButtonWithCheckAndText(((displaySizeX + 32)/2) - 16, 33, "Use Sound", 32, localStorage.useSound == "true", opsColsFg[menuSel == 3], opsColsBg[menuSel == 3], 3)) {
        menuUse(3)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, 37, "Keybindings", 32, opsColsFg[menuSel == 4], opsColsBg[menuSel == 4], 4)) {
        menuUse(4)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 5], opsColsBg[menuSel == 5], 5)) {
        menuUse(5)
    }
    
}

function randInt(a, b) {
    if (b) {
        return Math.floor(Math.random() * (b-a) + a)
    } else {
        return Math.floor(Math.random() * a)
    }
}

function updateFundraiserMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    if (lighthouseSprite) {
        drawRexSprite(6, 6, lighthouseSprite)
    }
    
    drawAsciiText(20, 8, "Fundraiser driven with", [128, 128, 128])
    drawAsciiText(20, 10, "Light", [190, 233, 255])
    drawAsciiText(25, 10, "house", [255, 255, 255])
    drawAsciiText(20, 12, "Raise money with Bitcoin", [128, 128, 128])
    
    drawAsciiText(20, 17, "Ganymede Gate needs your help to become the best space multiplayer", [255, 255, 255])
    drawAsciiText(20, 18, "roguelike!! Development is chugging along nicely, but there's some", [255, 255, 255])
    drawAsciiText(20, 19, "assets that need to be secured to make this project successful. So", [255, 255, 255])
    drawAsciiText(20, 20, "this fundraiser has been started with that goal in mind.", [255, 255, 255])
    drawAsciiText(20, 22, "Some of the most needed things at the moment are:", [255, 255, 255])
    drawAsciiText(20, 24, " * Domain with dedicated server", [255, 255, 255])
    drawAsciiText(20, 25, " * Reddit ads to attract new players", [255, 255, 255])
    drawAsciiText(20, 26, " * Lobby system for distributed servers around the globe", [255, 255, 255])
    drawAsciiText(20, 27, " * More art: Music, sprites, etc.", [255, 255, 255])
    
    drawAsciiText(20, 35, "Each donation counts!", [randInt(128, 255), randInt(128, 255), randInt(128, 255)])
    drawAsciiText(20, 37, "Download Lighthouse for your platform, install and then download", [255, 255, 255])
    drawAsciiText(20, 38, "the project to pledge and track progress.", [255, 255, 255])
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 14, "Download Lighthouse", 32, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 10, "Download project", 32, opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
}

function updateContactMenu() {
    terminal.clear()
    drawStarsAndGanymede()
    
    if (titleSprite) {
        drawRexSprite(Math.floor((displaySizeX + 32)/2) - 20, 0, titleSprite)
    }
    
    drawAsciiText(10, 25, "Made with ", [200, 200, 200], [0, 0, 0])
    drawAsciiText(20, 25, "\u2665 ", [225 + Math.cos(Date.now() / 100.0) * 30, 68, 126 + Math.sin(Date.now() / 200.0) * 60], [0, 0, 0])
    drawAsciiText(22, 25, "@ CCS/VE using Node.js, HTML5, WebGL and NW.js 100% Open Source", [200, 200, 200], [0, 0, 0])
    drawAsciiText(22, 26, "Licensed under the MIT License / Assets CC-BY 4.0", [200, 200, 200], [0, 0, 0])
    
    if (gplusSprite) {
        if (drawRexSprite(((displaySizeX + 32)/2) - 27, 40, gplusSprite)) {
            // Open G+
            OpenInNewTab("https://plus.google.com/+JohnVillar")
        }
        drawAsciiText(((displaySizeX + 32)/2) - 27, 51, "+JohnVillar", [200, 200, 200], [0, 0, 0])
    }
    
    if (twitterSprite) {
        if (drawRexSprite(((displaySizeX + 32)/2) + 14, 40, twitterSprite)) {
            // Open Twitter
            OpenInNewTab("https://twitter.com/johnvillarz")
        }
        drawAsciiText(((displaySizeX + 32)/2) + 14, 51, "@johnvillarz", [200, 200, 200], [0, 0, 0])
    }
    
    if (redditSprite) {
        if (drawRexSprite(((displaySizeX + 32)/2) - 6, 40, redditSprite)) {
            // Open Reddit
            OpenInNewTab("https://www.reddit.com/r/GanymedeGate/")
        }
        drawAsciiText(((displaySizeX + 32)/2) - 8, 51, "/r/GanymedeGate", [200, 200, 200], [0, 0, 0])
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
}
    
function updateTutorial() {
    terminal.clear()
    
    drawAsciiText(35, 20, "There should be some tut here, ain't it? \u263A", [255, 200, 200], [0, 0, 0])
    drawAsciiText(10, 23, "You can remap keys in the options menu", [255, 255, 200], [0, 0, 0])
    drawAsciiText(10, 25, "You can use WASD/Vikeys/Arrows to move (diagonals too)", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 27, "F fires, Shift+F uses alternate fire", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 29, "G grabs stuff from the floor", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 31, "R reloads weapons, Shift+R reloads alternate ammo", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 33, "T, will eventually, activate the active super power", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 35, "V toggles look mode", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 37, "Space activates levers and exits level", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 39, "Space also shows the action menu over stuff in look mode", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 41, "You can also use the mouse", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 43, "Shift+Direction lets you jump/trample (have fun with Melee and Swordmaster classes)", [200, 200, 200], [0, 0, 0])
    drawAsciiText(10, 45, "X, '.' or Keypad 5 skips one turn", [200, 200, 200], [0, 0, 0])
    
    var bgcol = [0, Math.floor(Math.sin(Date.now()/100.0) * 32 + 32) + 48, 0]
    drawAsciiText(18, 23, "remap keys", [255, 128, 128], [Math.floor(Math.sin(Date.now()/100.0) * 32 + 32) + 48, 0, 0])
    drawAsciiText(22, 25, "WASD/Vikeys/Arrows", [128, 255, 128], bgcol)
    drawAsciiText(10, 27, "F", [128, 255, 128], bgcol)
    drawAsciiText(19, 27, "Shift+F", [128, 255, 128], bgcol)
    drawAsciiText(10, 29, "G", [128, 255, 128], bgcol)
    drawAsciiText(10, 31, "R", [128, 255, 128], bgcol)
    drawAsciiText(29, 31, "Shift+R", [128, 255, 128], bgcol)
    drawAsciiText(10, 33, "T", [128, 255, 128], bgcol)
    drawAsciiText(10, 35, "V", [128, 255, 128], bgcol)
    drawAsciiText(10, 37, "Space", [128, 255, 128], bgcol)
    drawAsciiText(10, 39, "Space", [128, 255, 128], bgcol)
    drawAsciiText(10, 43, "Shift+Direction", [128, 255, 128], bgcol)
    drawAsciiText(10, 45, "X, '.' or Keypad 5", [128, 255, 128], bgcol)
    
    
    /*if (drawButtonWithText(((displaySizeX + 32)/2) - 18, displaySizeY - 10, "<< Previous", 16, opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
        menuUse(0)
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) + 2, displaySizeY - 10, "Next >>", 16, opsColsFg[menuSel == 1], opsColsBg[menuSel == 1], 1)) {
        menuUse(1)
    }*/
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 16, displaySizeY - 6, "Go back", 32, opsColsFg[menuSel == 2], opsColsBg[menuSel == 2], 2)) {
        menuUse(2)
    }
}

function saveKeyBindings() {
    localStorage.setItem("keyBindings", JSON.stringify(keyBindingNames))
}

function loadKeyBindings() {
    try {
        var newKeyBindings = localStorage.getItem("keyBindings")
        
        if ((typeof(newKeyBindings) !== "undefined") && (newKeyBindings != null)) {
            var parsedKeyBindingNames = JSON.parse(newKeyBindings)
            
            if ((typeof(parsedKeyBindingNames) !== "undefined") && (parsedKeyBindingNames != null)) {
                keyBindingNames = parsedKeyBindingNames
            }
        }
    } catch (e) {
        // Nothing, no keybindings then
    }
}

function updateKeybindings() {
    terminal.clear()
    
    drawStarsAndGanymede()
    
    var w4 = displaySizeX / 4
    var y = 6
    
    drawAsciiText(22, 3, "Keybindings (Use \u2191 and \u2193 to move between options)", [240, 240, 240], [0, 0, 0])
    
    var btnFn = function(num, key) {
        var name = keybindingsMenuIdentifier[num]
        var key = keyBindingNames[num]
        if (!key || (key.length <= 0)) {
            key = "Not set"
        }
        
        var py = y + Math.floor(num / 2) * 2
        var px = w4 * (1 + 2 * (num % 2))
        
        var fgBtCol = opsColsFg[menuSel == num]
        var bgBtCol = opsColsBg[menuSel == num]
        
        if (inspectKeyboardIndex >= 0) {
            if (inspectKeyboardIndex == num) {
                fgBtCol = [255, 255, 200]
                bgBtCol = [200, 100, 100]
            } else {
                fgBtCol = opsColsFg[false]
                bgBtCol = opsColsBg[false]
            }
        }
        
        drawAsciiText(px - Math.floor(name.length/2), py+1, name, [200, 200, 200], [0, 0, 0])
        if (drawButtonWithText(px + w4 - 8, py, key, 16, fgBtCol, bgBtCol, num)) {
            inspectKeyboardCodes = true
            inspectKeyboardIndex = num
            inspectKeyboardIdentifier = name
        }
    }
    
    btnFn(0)
    btnFn(1)
    y += 4
    btnFn(2)
    btnFn(3)
    y += 4
    btnFn(4)
    btnFn(5)
    y += 4
    btnFn(6)
    btnFn(7)
    y += 4
    btnFn(8)
    btnFn(9)
    y += 4
    btnFn(10)
    btnFn(11)
    y += 4
    btnFn(12)
    btnFn(13)
    y += 4
    btnFn(14)
    btnFn(15)
    y += 4
    btnFn(16)
    btnFn(17)
    
    if (drawButtonWithText(((displaySizeX + 32)/2) - 33, displaySizeY - 4, "Save changes", 32, 
        opsColsFg[menuSel == (itemsPerMenu[currentMenu]-2)], opsColsBg[menuSel == (itemsPerMenu[currentMenu]-2)], (itemsPerMenu[currentMenu]-2))) {
        menuUse((itemsPerMenu[currentMenu]-2))
    }
    
    if (drawButtonWithText(((displaySizeX + 32)/2) + 1, displaySizeY - 4, "Go back", 32, 
        opsColsFg[menuSel == (itemsPerMenu[currentMenu]-1)], opsColsBg[menuSel == (itemsPerMenu[currentMenu]-1)], (itemsPerMenu[currentMenu]-1))) {
        menuUse((itemsPerMenu[currentMenu]-1))
    }
}

var mouseActions = {
    "Walk here": function(x, y, data) {
        moveToDest(x, y)
    },
    "Wait": function(x, y, data) {
        pos(0, 0, false)
    },
    "Grab": function(x, y, data) {
        moveToDest(x, y, function() {
            grab() 
        })
    },
    "Attack (melee)": function(x, y, data) {
        moveToDest(x, y)
    },
    "Attack (melee, alternate)": function(x, y, data) {
        // Correct x and y relative to the player position display
        x = player.pos.x + (x - player.cpos.x)
        y = player.pos.y + (y - player.cpos.y)

        fire(true, {x: x, y: y})
    },
    "Attack (ranged)": function(x, y, data) {
        // Correct x and y relative to the player position display
        x = player.pos.x + (x - player.cpos.x)
        y = player.pos.y + (y - player.cpos.y)

        fire(false, {x: x, y: y})
    },
    "Attack (ranged, alternate)": function(x, y, data) {
        // Correct x and y relative to the player position display
        x = player.pos.x + (x - player.cpos.x)
        y = player.pos.y + (y - player.cpos.y)

        fire(true, {x: x, y: y})
    },
    "Activate": function(x, y, data) {
        moveToDest(x, y, function() {
            use()
        })
    },
    "Open door": function(x, y, data) {
        moveToDest(x, y, function() {
            // Nothing to do
        })
    },
    "Close door": function(x, y, data) {
        // TODO Fix this one
        moveToDest(x, y, function() {
        })
    },
    "Exit level": function(x, y, data) {
        moveToDest(x, y, function() {
            use()
        })
    },
    "Show inventory": function(x, y, data) {
        toggleInventory()
    },
    "Reload": function(x, y, data) {
        reload(false)
    },
    "Reload alternate": function(x, y, data) {
        reload(true)
    },
    "Stand": function(x, y, data) {
        if (player.crouch) {
            crouch()
        } else if (player.prone) {
            prone()
        }
    },
    "Crouch": function(x, y, data) {
        crouch()
    },
    "Prone": function(x, y, data) {
        prone()
    },
    "Use": function() { // Inventory action
        useInventory(inventoryIndex)
    },
    "Drop": function() { // Inventory action
        drop(inventoryIndex)
    },
    "Unload": function() { // Inventory action
        unload(inventoryIndex)
    },
    "Inspect": function() { // Inventory action
        inspect(inventoryIndex)
    },
    "God mode": function() {
        cheat('god')
    },
    "Inspect FSM": function(x, y, data) {
        var nonce = Math.round(Math.random() * 0x1FFFFFFF)
        cheat('showfsm', {x: x, y: y, id: nonce})
    }
}


function updateDisplayGameStarted() {
    var sx0 = Math.min(Math.max(player.pos.x - displaySizeX/2, 0), level[0].length - displaySizeX)
    var sy0 = Math.min(Math.max(player.pos.y - displaySizeY/2, 0), level.length - displaySizeY)
    
    minCoords.x = sx0
    minCoords.y = sy0
    
    terminal.clear()

    if (showingInventory) {
        descriptions = []
        drawInventory()
    } else {
        for (var y=0; y < displaySizeY; y++) {
            var levelRow = level[sy0 + y]
            for (var x=0; x < displaySizeX; x++) {
                var tile = levelRow[sx0 + x]
                var shroud = false
                var fg = "#AAAAAA"
                var bg = undefined
                var luma = undefined
                var glyph = asciiMapping[" "]
                
                if (tile.turn) {
                    if (tile.turn != turn) {
                        shroud = true
                    }
                }
                
                
                var cssClass = undefined
                if (tile.particles.length > 0) {
                    var ti = 0
                    
                    // trail: {from: "DDDDDD", to: "222222", ttl: 200, num: 3, inherit: false, velocity: [-0.25, 0.25]}
                    
                    while (ti < tile.particles.length) {
                        var part = tile.particles[ti]
                        glyph = part.pix
                        cssClass = part.cssClass
                        fg = part.fg || undefined
                        bg = part.bg || undefined
                        
                        var ct = Date.now()
                        
                        if ((ct - part.routeStart) >= part.timeGranule) {
                            if (part.trail) {
                                spawnTrail(part.trail, sx0+x, sy0+y)
                            }
                            
                            tile.particles.splice(ti, 1)
                            part.routeStart = ct
                            var pos = part.route.pop()
                            if (pos) {
                                if ((pos[1] >= 0)&&(pos[1] < level.length)&&
                                    (pos[0] >= 0)&&(pos[0] < level[0].length)) {
                                    level[pos[1]][pos[0]].particles.push(part)
                                }
                            }
                        } else {
                            ti++
                        }
                    }
                } else {
                    var fgAssigned = false
                    var hazardBackground = false
                    
                    if (tile.character) {
                        fgAssigned = true
                        if ((player.pos.x == x + sx0)&&(player.pos.y == y +sy0)) {
                            player.cpos = {x: x, y: y}
                        }
                        
                        glyph = tile.character.pix
                        if (tile.character.color) {
                            fg = tile.character.color
                        }
                        cssClass = tile.character.cssClass
                    } else if (tile.item) {
                        fgAssigned = true
                        glyph = tile.item.pix
                        fg = tile.item.color
                        cssClass = tile.item.cssClass
                    } else if (tile.debris) {
                        fgAssigned = true
                        glyph = tile.debris.pix
                        fg = tile.debris.color
                        cssClass = tile.debris.cssClass
                    } 
                    
                    if (tile.tile) {
                        if (!fgAssigned) {
                            glyph = tile.tile
                            
                            if (tile.fg) {
                                fg = "#" + tile.fg
                            }
                            
                            cssClass = tile.cssClass
                        }
                        
                        if (tile.bg) {
                            bg = "#" + tile.bg
                        }
                        
                        hazardBackground = 'damage' in tile
                        if (hazardBackground) {
                            cssClass = tile.cssClass
                            //console.log("Overriding cssClass for " + tile.cssClass)
                        }
                    }
                }
                
                if (cssClass) {
                    if (cssClass in colorMap) {
                        var rule = colorMap[cssClass]
                        
                        if ((!tile.fg)&&("color" in rule)) {
                            fg = fgColorFromColorMapRule(rule, x*y)
                        }
                        
                        if ((!tile.bg)&&("backgroundColor" in rule)&&(!hazardBackground || !fgAssigned)) {
                            bg = rule.backgroundColor
                        }
                        
                        if ((!tile.luma)&&("luma" in rule)) {
                            luma = rule.luma
                        }
                    } else if (cssClass in cssRules) {
                        var rule = cssRules[cssClass]
                        
                        if ((!tile.fg)&&(rule.style.color.length > 0)) {
                            fg = rule.style.color
                        }
                        
                        if ((!tile.bg)&&(rule.style.backgroundColor.length > 0)&&(!hazardBackground || !fgAssigned)) {
                            bg = rule.style.backgroundColor
                        }
                    }
                }
                
                var lgt = tile.light
                if (shroud) {
                    fg = "#181818"
                    
                    if (bg) {
                        bg = "#000000"
                    }
                    
                    lgt = undefined
                }
                
                terminal.setPixel(x, y, glyph, fg, bg, luma, lgt)
            }
        }
    }
    
    updateAttrs()
    updateLogs()

    if ((typeof(playerAttrs) != "undefined") && (playerAttrs.hp.pos <= 0)) {
        actionMenuShown = false
        
        if (player.isAlive) {
            player.isAlive = false
            lastClick = [-1, -1]
            lastMove = [-1, -1]
        }
        
        if (drawButtonWithText(((displaySizeX + 32)/2) - 24, displaySizeY - 4, "Return to Menu", 16, opsColsFg[true], opsColsBg[true], 0)) { //opsColsFg[menuSel == 0], opsColsBg[menuSel == 0], 0)) {
            currentMenu = 0
            gameStarted = false
            lastClick = [-1, -1]
            lastMove = [-1, -1]
            destinationMovement = undefined
            
            level = []
            queuedAnns = []
            currentTips = []
            showingInventory = false
            announcements = []
            
            reconnect()
        }
    } else {
        player.isAlive = true
    }
    
    for (var i=0; i < descriptions.length; i++) {
        var desc = descriptions[i]
        if (desc.lines.length > 1) {
            for (var j=0; j < desc.lines.length; j++) {
                var fg = [192,192,192]
                var bg = [32,32,32]
                var luma = [0,0,0]
                var d = desc.lines[j]
                
                if ("cssClass" in d) {
                    if (d.cssClass in colorMap) {
                        var rule = colorMap[d.cssClass]
                        
                        if ((!tile.fg)&&("color" in rule)) {
                            fg = fgColorFromColorMapRule(rule, x*y)
                        }
                        
                        if ((!tile.bg)&&("backgroundColor" in rule)) {
                            bg = rule.backgroundColor
                        }
                        
                        if ((!tile.luma)&&("luma" in rule)) {
                            luma = rule.luma
                        }
                    }
                }
                
                if ("fg" in d) {
                    fg = d.fg
                }
                
                drawAsciiText(desc.pos[0], desc.pos[1] + j, d.text, fg, bg, luma)
            }
        }
    }
    
    for (var i=0; i < currentPkts.length; i++) {
        var pkt = currentPkts[i]
        
        var fg = [192,192,192]
        var bg = [32,32,32]
        var luma = [0,0,0]
        
        var dt = (Date.now() - pkt.initialTime)
        var txt
        var dx = 0
        
        if ((dt < 500) && (dt > 0)) {
            var ln = Math.floor(dt/500.0*pkt.txt.length)
            txt = pkt.txt.slice(0, ln)
        } else if ((dt > 2500) && (dt < 3000)) {
            var ln = Math.floor((1.0 - (3000 - dt)/500.0)*pkt.txt.length)
            txt = pkt.txt.slice(ln)
            dx = ln
        } else if ((dt > 0) && (dt < 3000)) {
            txt = pkt.txt
        }
        
        if (txt) {
            drawAsciiText(pkt.x + dx, pkt.y-1, txt, fg, bg, luma)
        }
    }
    
    if (actionMenuShown) {
        var mx = actionMenuCenter[0], my = actionMenuCenter[1], mw = 0, mh = actionMenuActions.length * 4
        for (var i=0; i < actionMenuActions.length; i++) {
            if (mw < actionMenuActions[i].text.length) {
                mw = actionMenuActions[i].text.length
            }
        }
        
        mx += 2
        my -= Math.floor(mh / 2)
        
        if (my < 0) {
            my = 0
        }
        
        if ((my + mh) >= displaySizeY) {
            my = displaySizeY - mh - 1
        }
        
        if ((mx + mw) >= (displaySizeX - 1)) {
            mx = actionMenuCenter[0] - 3 - mw
        }
        
        var verx = ((lastMove[0] >= mx) && (lastMove[0] < (mx + mw + 2)))
        for (var i=0; i < actionMenuActions.length; i++) {
            var by = my + i * 4
            var very = (lastMove[1] >= by) && (lastMove[1] < (by + 3))
            var verKeyb = menuSel == i
            
            if (verx && very) {
                menuSel = i
            }
            
            var totVer = (verx && very) || verKeyb
            
            if (drawButtonWithText(mx, by, actionMenuActions[i].text, mw + 2, (actionMenuActions[i].fg || opsColsFg)[totVer], (actionMenuActions[i].bg || opsColsBg)[totVer], i)) {
                /*actionMenuShown = false
                lastClick = [-1, -1]
                
                if (mouseActions[actionMenuActions[i].text]) {
                    var pos = actionMenuActions[i].pos || {x: -1, y: -1} // A good fallback to avoid unnecessary logic
                    mouseActions[actionMenuActions[i].text](pos.x, pos.y, actionMenuActions[i])
                }*/
                
                activateMenuAction(i)
            }
        
        }
    }

}

function drawConsoleBar(x, y, w, h, percent) {
    var cols = [[255, 0, 0], [255, 255, 0], [0, 255, 0], [0, 0, 255]]
    
    for (var iy=0; iy < h; iy++) {
        for (var ix=0; ix < w; ix++) {
            var p = ix / w
            var cp = Math.floor(p*4)
            var col = cols[cp]
            
            if (p < percent) {
                terminal.setPixel(x + ix, y + iy, 178, col, [0,0,0])
            } else {
                terminal.setPixel(x + ix, y + iy, 178, [0,0,0], [64, 64, 64])
            }
        }
    }
}

function pad(txt, l) {
    while (txt.length < l) {
        txt = " " + txt
    }
    
    return txt
}

function padR(txt, l) {
    while (txt.length < l) {
        txt = txt + " "
    }
    
    return txt
}

function drawAsciiText(x, y, txt, fg, bg, luma) {
    for (var i=0; i < txt.length; i++) {
        var c = txt.charAt(i)
        if (c in asciiMapping) {
            terminal.setPixel(x + i, y, asciiMapping[c], fg, bg, luma)
        }
    }
}

function drawRexSprite(x, y, spr) {
    var clicked = false
    for (var l=0; l < spr.layers.length; l++) {
        var layer = spr.layers[l]
        
        for (var iy=0; iy < layer.height; iy++) {
            for (var ix=0; ix < layer.width; ix++) {
                var ras = layer.raster[iy + ix * layer.height]
                
                if (!((ras.bg.r == 255) && (ras.bg.g == 0) && (ras.bg.b == 255))) {
                    terminal.setPixel(x + ix, y + iy, ras.asciiCode,
                        [ras.fg.r, ras.fg.g, ras.fg.b],
                        [ras.bg.r, ras.bg.g, ras.bg.b])
                        
                    if ((lastClick[0] == (x + ix))&&(lastClick[1] == (y + iy))) {
                        lastClick[0] = -1
                        lastClick[1] = -1
                        clicked = true
                    }
                }
            }
        }
    }
    
    return clicked
}

function pruneWeaponName(name) {
    //return name.toLocaleLowerCase().replace(/\s/g, '')
    return name.replace(/\s/g, '')
}

function updateAttrs() {
    if (playerAttrs) {
        var y = 2
        
        drawAsciiText(displaySizeX + 2, y, "Plyr. " + ownUsername, [0, 255, 0], [0, 0, 0])
        y += 2
        
        drawAsciiText(displaySizeX + 2, y, "HP " + pad(playerAttrs.hp.pos, 3) + "/" + playerAttrs.hp.max, [0, 255, 0], [0, 0, 0])
        drawConsoleBar(displaySizeX + 13, y, 12, 1, playerAttrs.hp.pos / playerAttrs.hp.max)
        y += 2
        
        drawAsciiText(displaySizeX + 2, y, "AR " + pad(playerAttrs.armor.pos, 3) + "/" + playerAttrs.armor.max, [0, 255, 0], [0, 0, 0])
        drawConsoleBar(displaySizeX + 13, y, 12, 1, playerAttrs.armor.pos / playerAttrs.armor.max)
        y += 2
        
        drawAsciiText(displaySizeX + 2, y, "ST " + pad(playerAttrs.strength.pos, 3) + "/" + playerAttrs.strength.max, [0, 255, 0], [0, 0, 0])
        drawConsoleBar(displaySizeX + 13, y, 12, 1, playerAttrs.strength.pos / playerAttrs.strength.max)
        y += 2
        
        drawAsciiText(displaySizeX + 2, y, "PR " + pad(playerAttrs.precision.pos, 3) + "/" + playerAttrs.precision.max, [0, 255, 0], [0, 0, 0])
        drawConsoleBar(displaySizeX + 13, y, 12, 1, playerAttrs.precision.pos / playerAttrs.precision.max)
        y += 2
        
        drawAsciiText(displaySizeX + 2, y, "SP " + pad(playerAttrs.speed.pos, 3) + "/" + playerAttrs.speed.max, [0, 255, 0], [0, 0, 0])
        drawConsoleBar(displaySizeX + 13, y, 12, 1, playerAttrs.speed.pos / playerAttrs.speed.max)
        y += 2
        
        drawAsciiText(displaySizeX + 2, y, "BAT " + pad(Math.round(playerAttrs.battery), 3), [0, 255, 0], [0, 0, 0])
        drawConsoleBar(displaySizeX + 13, y, 12, 1, playerAttrs.battery / 100)
        y += 2
        
        var firingPrimary = false
        var firingAlternate = false
        
        if (typeof(player.firing) != "undefined") {
            firingPrimary = player.firing == "primary"
            firingAlternate = player.firing == "alternate"
        }
        
        drawAsciiText(displaySizeX + 2, y, "Weapon", [0, 255, 0], [0, 0, 0])
        y += 2
        drawAsciiText(displaySizeX + 2, y, currentWeapon.name, [0, 255, 0], [0, 0, 0])
        y++
        
        if (typeof(currentWeapon.ammoType) !== "undefined") {
            var bgColor = firingPrimary?[128, 128, 0]:[0, 0, 0]
            drawAsciiText(displaySizeX + 2, y, padR(currentWeapon.ammoType, 30), [0, 255, 0], bgColor)
            y++
        }
        
        if (currentWeapon.ammoMax !== 0) {
            var ammoStr = "Ammo " + pad(currentWeapon.ammo, 3) + "/" + currentWeapon.ammoMax
            drawAsciiText(displaySizeX + 2, y, padR(ammoStr, 30), [0, 255, 0], bgColor)
            drawConsoleBar(displaySizeX + 15, y, 10, 1, currentWeapon.ammo / currentWeapon.ammoMax)
            y++
        }
            
        drawAsciiText(displaySizeX + 2, y, "Dmg. " + currentWeapon.damage[0] + " - " + currentWeapon.damage[1], [0, 255, 0], [0, 0, 0])
        y++
        
		if (currentWeapon.alternate) {
            if (typeof(currentWeapon.alternate.ammoType) !== "undefined") {
                bgColor = firingAlternate?[128, 128, 0]:[0, 0, 0]
                drawAsciiText(displaySizeX + 2, y, padR(currentWeapon.alternate.ammoType, 30), [0, 255, 128], bgColor)
                y++
            }
            
            if (currentWeapon.alternate.ammoMax !== 0) {
                ammoStr = "Ammo " + pad(currentWeapon.alternate.ammo, 3) + "/" + currentWeapon.alternate.ammoMax
                drawAsciiText(displaySizeX + 2, y, padR(ammoStr, 30), [0, 255, 128], bgColor)
                drawConsoleBar(displaySizeX + 15, y, 10, 1, currentWeapon.alternate.ammo / currentWeapon.alternate.ammoMax)
                y++
            }
		}
		
        if (!((currentWeapon.id in weaponSprites) || (currentWeapon.name in weaponSprites))) {
            
            var f = function(weap) {
                loadGenXpSprite(pruneWeaponName(weap), function(sp) { 
					weaponSprites[weap] = sp 
				})
            }
            var n = currentWeapon.id
            if (n == "------") {
                loadXpSprite(pruneWeaponName(currentWeapon.name.toLowerCase()), (function(nm) {
                        return function(sp) { weaponSprites[nm] = sp }
                    })(currentWeapon.name))
            } else {
                weaponSprites[currentWeapon.id] = undefined
                f(currentWeapon.id)
            }
        } else if (weaponSprites[currentWeapon.id]) {
            var spr = weaponSprites[currentWeapon.id]
            
            drawRexSprite(displaySizeX + 2, y, spr)
        } else if (currentWeapon.name in weaponSprites) {
            var spr = weaponSprites[currentWeapon.name]
            
            drawRexSprite(displaySizeX + 2, y, spr)
        }
        
        var ramp = [[64, 0, 0], [128, 0, 0], [128, 64, 0], [128, 128, 0], [64, 128, 0], [0, 128, 64], [0, 128, 128], [64, 192, 192], [128, 192, 192], [255, 255, 255]]
        
        if (displaySuPow < playerAttrs.suPow) {
            displaySuPow++
        } else if (displaySuPow > playerAttrs.suPow) {
            displaySuPow--
        }
        
        var maxY = displaySizeY - Math.floor(displaySuPow * displaySizeY / 100)
        
        var colorCycle = Math.floor(Date.now() / 50.0)
        //var bg = (maxY <= 0)?ramp[Math.floor((Math.sin(Date.now()/50.0)+1) / 2 * (ramp.length - 1))]:[0,0,0]
        
        for (var i=displaySizeY - 1; i >= maxY; i--) {
            var fgIdx = ramp.length - Math.floor(i * ramp.length / displaySizeY) - 1
            var bg = (maxY <= 0)?ramp[Math.floor((Math.sin(Date.now()/150.0 + Math.cos(Date.now()/300.0 + i*10.0) * 0.5)+1) / 2 * (ramp.length - 1))]:[0,0,0]
            
            var fg = (maxY <= 0)?[0, 0, 0]:ramp[fgIdx]
            drawAsciiText(displaySizeX, i, "\u25B2", fg, bg)
        }
    }
}

function updateLogs() {
    drawAsciiText(displaySizeX + 2, 41, "Game log", [0, 255, 0], [0, 0, 0])
    
    var m = announcements.length-1
    var l = Math.min(m, displaySizeY - 39)
    for (var i=0; i < l; i++) {
        var ann = announcements[m - i]
        
        if (ann.length >= 30 ) {
            var granule = 400
            var tmln = granule * (ann.length + 8 - 30)
            var p = Math.floor(((Date.now() % tmln) / granule)) - 4
            if (p < 0) {
                p = 0
            } else if ((p + 30) >= ann.length) {
                p = ann.length - 30
            }
            
            ann = ann.slice(p, p+64)
        }
        
        drawAsciiText(displaySizeX + 2, 42 + i, ann, [64, 200, 64], [0, 0, 0])
    }
} 

function showPkts(pkts) {
    currentPkts = currentPkts.concat(pkts.map(function(pkt) {
        pkt.initialTime = Date.now() + Math.floor(Math.random() * 400)
        var txt = "Unknown"
        
        if ('hostile_seen' in pkt.msg) {
            txt = 'Hostile seen!'
        } else if ('need_squad' in pkt.msg) {
            txt = 'Searching squad'
        } else if ('have_squad' in pkt.msg) {
            txt = 'Join my squad ' + pkt.msg.have_squad.squad
        } else if ('retreat' in pkt.msg) {
            txt = 'Retreating'
        } else if ('need_backup' in pkt.msg) {
            txt = 'Backup!!!!'
        } else if ('new_squad' in pkt.msg) {
            txt = 'Formed squad ' + pkt.msg.new_squad.name
        } else if ('exploring' in pkt.msg) {
            txt = 'Team follow me'
        } else if ('retreating' in pkt.msg) {
            txt = 'Retreat!'
        } else if ('joined_squad' in pkt.msg) {
            txt = 'Joined ' + pkt.msg.joined_squad.squad
        } else {
            console.log(pkt)
        }
        
        pkt.txt = txt
        
        return pkt
    }))
    
    var i = 0
    while (i < currentPkts.length) {
        var pkt = currentPkts[i]
        
        if ((Date.now() - pkt.initialTime) >= 1000) {
            currentPkts.splice(i, 1)
        } else {
            i++
        }
    }
}

function absolutePosToWindow(x, y) {
    /*if (x < minCoords.x) {
        x = minCoords.x
    } else if (x >= minCoords.x + displaySizeX) {
        x = minCoords.x + displaySizeX - 1
    }
    
    if (y < minCoords.y) {
        y = minCoords.y
    } else if (y >= minCoords.y + displaySizeY) {
        y = minCoords.y + displaySizeY - 1
    }
    
    var tx = x - minCoords.x
    var ty = y - minCoords.y
    
    var table = $("#term")
    var cl = $(table[0].rows[ty].cells[tx])
    
    return cl.offset()*/
    
}

function spawnParticles() {
    if (typeof(particles) != "undefined") {
        for (var i=0; i < particles.length; i++) {
            var part = particles[i]

            if (part.movType == "instant") {
                if (!part.route) {
                    part.route = TraceLine(part.ox, part.oy, part.dx, part.dy).reverse()
                    part.routeStart = Date.now() + part.delay
                    part.timeGranule = part.ttl / part.route.length
                }
                
                var pos = part.route[part.route.length - 1]
                if (pos) {
                    if ((pos[1] >= 0)&&(pos[1] < level.length)&&
                            (pos[0] >= 0)&&(pos[0] < level[0].length)) {
                        level[pos[1]][pos[0]].particles.push(part)
                    }
                }
            }
        }
    }
}

function initAsciiDisplay(id, w, h) {
    terminal = new ASCIITerminal({
        font: './static/CGA8x8thick.png',
        target: 'term',
        console: {width: w + 32, height: h},
        consoleScale: (localStorage.dupConSz == "true")?2:1,
        use2xsai: localStorage.use2xsai == "true"
    })
    
    terminal.ready(function() {
        render()
    })
    
    terminal.on('click', function(x, y) {
        clickCell(x, y)
    })
    
    terminal.on('mousemove', function(x, y) {
        moveCell(x, y)
    })
}

var mustUpdateFsms = false
var handlers = {
    init: function(obj) {
        announceMsg("Initializing game")
        console.log(obj)
        player.pos = obj.pos
        levelTileset = obj.levelTileset
        canCheat = obj.canCheat
        
        if (canCheat) {
            var s = document.createElement("script")
            s.type = "text/javascript"
            s.src = "https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"
            $(document.body).append(s)
        }
        
        for (var y=0; y < obj.dim.h; y++) {
            var row = Array.apply(null, new Array(obj.dim.w+1)).map(function(){return {particles: []}})
            level.push(row)
        }
        
        /*var lst = $("#player_list")
        for (var i=0; i < obj.player_list.length; i++) {
            var plyr = obj.player_list[i]
            if (!(plyr.username in playerDivs)) {
                var dv = $("<div>")
                dv.text(plyr.username)
                
                lst.append(dv)
                if (plyr.username == ownUsername) {
                    dv.css("color", "#04f")
                } else {
                    dv.css("color", "#ff0")
                }
                playerDivs[plyr.username] = dv
            }
        }*/
        
        useSounds = localStorage.useSound == "true"
        gameStarted = true
        pos()
    },
    pos: function(obj) {
        player.pos.x = obj.plyr_pos.x
        player.pos.y = obj.plyr_pos.y
        player.fov = obj.fov
        player.crouch = obj.crouch
		player.prone = obj.prone
        turn++
        
        for (var y=0; y < obj.scope.length; y++) {
            var py = y + obj.pos.y
            
            if ((py >= 0)&&(py < level.length)) {
                for (var x=0; x < obj.scope[y].length; x++) {
                    var px = x + obj.pos.x
                    
                    if ((px >= 0) && (px < level[y + obj.pos.y].length)) {
                        if (obj.scope[y][x]) {
                            var sc = obj.scope[y][x]
                            sc.turn = turn
                            sc.particles = level[py][px].particles
                            level[py][px] = sc
                        }
                    }
                }
            }
        }
        
        particles = obj.particles
        
        if (typeof(obj.attrs) != "undefined") {
            playerAttrs = obj.attrs
        }
        
        updateWeapon(obj.weapon)
        
        updateDisplay()
        
        if ("damaged" in obj) {
            showDamage = obj.damaged?30:0
        }
        
        if ("inventory" in obj) {
            inventoryList = obj.inventory
        }
        
        if (useSounds) {
            for (var i=0; i < obj.snds.length; i++) {
                var snd = obj.snds[i]
                
                createjs.Sound.play(snd.s, {
                    volume: snd.v/128.0,
                    pan: snd.p/128.0,
                    delay: snd.d
                })
            }
        }
        
        spawnParticles()
        if (("couldMove" in obj) && (obj.couldMove)) {
            tryMoveTowardsDestination() // If there's a standing command, move
        }
        
        if (obj.fsms) {
            for (var i=0; i < obj.fsms.length; i++) {
                console.log(obj.fsms[i])
            }
        }
        
        if (mustUpdateFsms) {
            cheat('updatefsms')
        }
        
        if (obj.pkts) {
            showPkts(obj.pkts)
        }
    },
    new_player: function(obj) {
        announceMsg("Player " + obj.username + " joined the game!")
        var lst = $("#player_list")
        var dv = $("<div>")
        dv.text(obj.username + " (" + obj.player_class + ")")
        
        if (obj.username == ownUsername) {
            dv.css("color", "#04f")
        } else {
            dv.css("color", "#ff0")
        }
        
        lst.append(dv)
        playerDivs[obj.username] = dv
    },
    player_left: function(obj) {
        announceMsg("Player " + obj.username + " left the game!")
        /*var dv = playerDivs[obj.username]
        dv.remove()*/
    },
    player_died: function(obj) {
        var dv = playerDivs[obj.username]
        dv.css("color", "#800")
        if (typeof(obj.reason) != "undefined") {
            if (obj.reason == "lava") {
                announceMsg("Player " + obj.username + " took a dive into lava")
            } else if (obj.reason == "acid") {
                announceMsg("Player " + obj.username + " decided to shed some skin on acid")
            } else if (obj.reason == "plasma") {
                announceMsg("Player " + obj.username + "'s subatomic particles got disorganized")
            } else if (obj.reason == "9mm") {
                announceMsg("Player " + obj.username + " bled through tiny holes")
            } else if (obj.reason == "9mm FMJ") {
                announceMsg("Player " + obj.username + " internal organs failed")
            } else if (obj.reason == "12ga shells") {
                announceMsg("Player " + obj.username + " was splattered on the walls")
            } else {
                announceMsg("Player " + obj.username + " died: " + obj.reason)
            }
        } else {
            announceMsg("Player " + obj.username + " died")
        }
    },
    player_downstairs: function(obj) {
        var dv = playerDivs[obj.username]
        dv.css("color", "#FFF")
        announceMsg("Player " + obj.username + " went downstairs")
    },
    inventory: function(obj) {
        inventoryList = obj.inventory
    },
    new_level: function(obj) {
        announceMsg("You enter a new level!")
        gameStarted = false
        while (level.length > 0) {
            level.pop()
        }
    },
    fsm_vars: function(obj) {
        console.log(obj)
        mustUpdateFsms = true
    },
    fsms_updates: function(obj) {
        for (x in obj.fsms) {
            if (obj.fsms.hasOwnProperty(x)) {
                updateFsm(obj.fsms[x], x)
            }
        }
    }
}

var fsmDivs = {}
function updateFsm(fsm, id) {
    var dv, title
    if (id in fsmDivs) {
        dv = fsmDivs[id]
        title = dv.find('h3')
    } else {
        dv = $("<div>")
        dv.draggable()
        dv.addClass('fsm')
        title = $("<h3>")
        dv.append(title)
        
        fsmDivs[id] = dv
        
        $(document.body).append(dv)
    }
    title.text(fsm.currentState.name)
    
    for (name in fsm.variables) {
        if (fsm.variables.hasOwnProperty(name)) {
            var value = fsm.variables[name]
            
            var sp = dv.find('#' + id + '_' + name), b, t
            
            if (sp.length == 0) {
                sp = $("<div>")
                sp[0].id = id + '_' + name
                b = $("<b>")
                sp.append(b)
                t = $("<i>")
                sp.append(t)
            } else {
                b = sp.find('b')
                t = sp.find('i')
            }

            b.text(name + ":")
            
            if ((typeof(value) === "object") && ('x' in value) && ('y' in value)) {
                t.text('(' + value.x + ', ' + value.y + ')')
            } else {
                t.text(value)
            }
            
            dv.append(sp)
        }
    }
}

var wsPortPart = ":8080"
if (window.location.hostname.indexOf("ganymedegate") >= 0) {
    // OpenShift needs the WebSocket to connect to port 8000
    wsPortPart = ":8000"
}

function startConnection() {
    var sck = new WebSocket("ws://" + (window.location.hostname || "127.0.0.1") + wsPortPart)
    sck.onopen = function (event) {
        //
    }

    sck.onmessage = function (event) {
        //totalChars += event.data.length
        //console.log("~" + (totalChars/1024) + " Kb")*/
        var msg = JSON.parse(pako.inflate(event.data, { to: 'string' }))
        
        if (typeof(msg.type) != 'undefined') {
            handlers[msg.type](msg)
        }
        
        if (typeof(msg.msgs) != 'undefined') {
            queueAnnouncements(msg.msgs)
        }
    }

    sck.onclose =  function (event) {
        console.log("Close: " + event)
    }

    sck.onerror =  function (event) {
        console.log("Error: " + event)
    }
    
    return sck
}

var sock = startConnection()

function reconnect() {
    sock.close()
    sock = startConnection()
}

function send(obj) {
    sock.send(JSON.stringify(obj))
}

var fnCommands = {
    up: function(shift) {
        if (gameStarted) {
            if (actionMenuShown) {
                menuSel -= 1
                if (menuSel < 0) {
                    menuSel += actionMenuActions.length
                }
            } else if (showingInventory) {
                inventoryIndex--
            } else if (keyboardLook) {
                moveCell(lastMove[0], Math.max(0, lastMove[1] - 1))
                return "cursor"
            } else {
                pos(0, -1, shift)
            }
        } else {
            menuSel = menuSel - 1
            if (menuSel < 0) {
                menuSel += menuOptionsNumber
            }            
        }
    },
    down: function(shift) {
        if (gameStarted) {
            if (actionMenuShown) {
                menuSel = (menuSel + 1) % actionMenuActions.length
            } else if (showingInventory) {
                inventoryIndex++
            } else if (keyboardLook) {
                moveCell(lastMove[0], Math.min(displaySizeY - 1, lastMove[1] + 1))
                return "cursor"
            } else {
                pos(0, 1, shift)
            }
        } else {
            menuSel = (menuSel + 1) % menuOptionsNumber
        }
    },
    left: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.max(0, lastMove[0] - 1), lastMove[1])
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                pos(-1, 0, shift)
            }
        }
    },
    right: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.min(displaySizeX - 1, lastMove[0] + 1), lastMove[1])
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                pos(1, 0, shift)
            }
        }
    },
    upleft: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.max(0, lastMove[0] - 1), Math.max(0, lastMove[1] - 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                pos(-1, -1, shift)
            }
        }
    },
    upright: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.min(displaySizeX - 1, lastMove[0] + 1), Math.max(0, lastMove[1] - 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                pos(1, -1, shift)
            }
        }
    },
    downright: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.min(displaySizeX - 1, lastMove[0] + 1), Math.min(displaySizeY - 1, lastMove[1] + 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                pos(1, 1, shift)
            }
        }
    },
    downleft: function(shift) {
        if (gameStarted) {
            if (showingInventory) {
            } else if (keyboardLook) {
                moveCell(Math.max(0, lastMove[0] - 1), Math.min(displaySizeY - 1, lastMove[1] + 1))
                return "cursor"
            } else if (actionMenuShown) {
                // Do nothing
            } else {
                pos(-1, 1, shift)
            }
        }
    },
    wait: function(shift) {
        if (keyboardLook) {
        } else if (actionMenuShown) {
            // Do nothing
        } else {
            pos(0, 0, shift)
        }
    },
	prone: function() {
		prone()
	},
	crouch: function() {
		crouch()
	},
    toggleKeyboardLook: function() {
        if (gameStarted && !showingInventory) {
            keyboardLook = !keyboardLook
            
            if (keyboardLook) {
                lastMove = [player.cpos.x, player.cpos.y]
                
                return "cursor"
            }
        }
    }
}

function shutdownKeyboardLook() {
    keyboardLook = false
    lastMove = [-1, -1]
}

function cancelEverything() {
    shutdownKeyboardLook()
    cancelTarget()
    finishEditText()
    showingInventory = false
    actionMenuShown = false
}

var kb_hnd = {
    // Up group
    "Up": fnCommands.up,
    "k": fnCommands.up,
    "U+004B": fnCommands.up,
    "w": fnCommands.up,
    "U+0057": fnCommands.up,
    
    // Down group
    "Down": fnCommands.down,
    "j": fnCommands.down,
    "U+004A": fnCommands.down,
    "s": fnCommands.down,
    "U+0053": fnCommands.down,
    
    // Left group
    "Left": fnCommands.left,
    "h": fnCommands.left,
    "U+0048": fnCommands.left,
    "a": fnCommands.left,
    "U+0041": fnCommands.left,
    
    // Right group
    "Right": fnCommands.right,
    "l": fnCommands.right,
    "U+004C": fnCommands.right,
    "d": fnCommands.right,
    "U+0044": fnCommands.right,
    
    // Upleft group
    "Home": fnCommands.upleft,
    "y": fnCommands.upleft,
    "U+0059": fnCommands.upleft,
    "q": fnCommands.upleft,
    "U+0051": fnCommands.upleft,
    
    // Upright group
    "PageUp": fnCommands.upright,
    "u": fnCommands.upright,
    "U+0055": fnCommands.upright,
    "e": fnCommands.upright,
    "U+0045": fnCommands.upright,
    
    // Downright group
    "PageDown": fnCommands.downright,
    "n": fnCommands.downright,
    "U+004E": fnCommands.downright,
    "c": fnCommands.downright,
    "U+0043": fnCommands.downright,
    
    // Downleft group
    "End": fnCommands.downleft,
    "b": fnCommands.downleft,
    "U+0042": fnCommands.downleft,
    "z": fnCommands.downleft,
    "U+005A": fnCommands.downleft,
    
    // Wait group
    "Clear": fnCommands.wait,
    ".": fnCommands.wait,
    "U+002E": fnCommands.wait,
    "x": fnCommands.wait,
    "U+0058": fnCommands.wait,
    
    " ": use,
    "U+0020": use,
    
    "g": grab,
    "U+0047": grab,
    
    "f": fire,
    "U+0046": fire,
    
    "t": superPower,
    "U+0054": superPower,
    
    "r": reload,
    "U+0052": reload,
	
	"p": fnCommands.prone,
    "U+0050": fnCommands.prone,
	
	"o": fnCommands.crouch,
    "U+004F": fnCommands.crouch,
    
    "U+00BA": showTips, // Tab
    "i": toggleInventory,
    "U+0049": toggleInventory,
    
    "v": fnCommands.toggleKeyboardLook,
    "U+0056": fnCommands.toggleKeyboardLook,
    
    "U+001B": cancelEverything
}

function render() {
    updateDisplay()
    if (terminal) {
        terminal.render(showDamage)
        if (showDamage > 0) {
            showDamage--
        }
    }
    requestAnimationFrame(render)
}

var preventNextKeypress = false
var gameInputEnabled = true

function disableGameInput() {
    gameInputEnabled = false
}

function enableGameInput() {
    gameInputEnabled = true
}

function collectStyleSheetRules() {
    for (var rl=0; rl < document.styleSheets.length; rl++) {
        var rules = document.styleSheets[rl].rules
        
        if ((rules) && (typeof(rules.length) != "undefined")) {
            for (var i=0; i < rules.length; i++) {
                var rule = rules[i]
                if (rule.selectorText && (rule.selectorText.charAt(0) == '.')) {
                    cssRules[rule.selectorText.slice(1)] = rule
                }
            }
        }
    }
}

function toggle_help() {
    $("#help").toggle()
}

function updateShaders() {
    var fs = $("#fs-edit").val()
    var vs = $("#vs-edit").val()
    
    ASCIITerminal.util.fragmentShaders["default"] = fs
    ASCIITerminal.util.vertexShaders["default"] = vs
    
    terminal.gl.shaderProgram = ASCIITerminal.util.initShaders(terminal.gl)[0]
}

function setupMusic() {
    if (localStorage.useMusic == "true") {
        if (!bgm && !gameStarted) {
            bgm = createjs.Sound.play("seedybg", {
                        volume: 0.5,
                        loop: -1
                    })
        } else {
            bgm.play()
        }
        
    } else {
        bgm.stop()
    }
}

function menuUse(n) {
    if (typeof(n) != "undefined") {
        menuSel = n
        lastClick = [-1, -1]
    }
    
    if (currentMenu == 0) {
        // Start menu
        if (menuSel == 0) {
            if (!tutorialSeen) {
                tutorialSeen = true
                localStorage.tutorialSeen = true
                currentMenu = 4
                menuSel = 1
                tutorialPage = 0
            } else {
                currentMenu = 1
                menuSel = 0
            }
        } else if (menuSel == 1) {
            currentMenu = 2
            menuSel = 0
        } else if (menuSel == 2) {
            currentMenu = 3
            menuSel = 0
        } else if (menuSel == 3) {
            if (!tutorialSeen) {
                currentMenu = 1
                menuSel = 0
            } else {
                tutorialSeen = true
                localStorage.tutorialSeen = true
                currentMenu = 4
                menuSel = 1
                tutorialPage = 0
            }
        } else if (menuSel == 4) {
            window.close()
        }
    } else if (currentMenu == 1) {
        // Char select
        if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 0
            finishEditText()
        } else if (menuSel == (itemsPerMenu[currentMenu] - 2)) {
            beginEditText(ownUsername, function(x, finished) {
                ownUsername = x
                if (finished) {
                    start()
                }
            })
        } else {
            playerPickClass = playerClasses[menuSel].id
            
            if (typeof(ownUsername) === "undefined") {
                menuUse(playerClasses.length)
            } else {
                finishEditText()
                start()
            }
        }
    } else if (currentMenu == 2) {
        // Options
        if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 1
        } else if (menuSel == 0) {
            localStorage.dupConSz = !(localStorage.dupConSz == "true")
        } else if (menuSel == 1) {
            localStorage.use2xsai = !(localStorage.use2xsai == "true")
        } else if (menuSel == 2) {
            localStorage.useMusic = !(localStorage.useMusic == "true")
            setupMusic()
        } else if (menuSel == 3) {
            localStorage.useSound = !(localStorage.useSound == "true")
        } else if (menuSel == 4) {
            currentMenu = 5
            menuSel = 0
        }
    } else if (currentMenu == 3) {
        // Contact
        if (menuSel == 0) {
            //window.open("https://www.vinumeris.com/lighthouse")
            currentMenu = 0
            menuSel = 2
        /*} else if (menuSel == 1) {
            window.open("https://lighthouse.bitseattle.com/lighthouse-projects/ganymede-gate-fundraiser.lighthouse-project")
        } else if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 2*/
        }
    } else if (currentMenu == 4) {
        if (menuSel == 0) {
            tutorialPage = tutorialPage - 1
        } else if (menuSel == 1) {
            tutorialPage = tutorialPage + 1
        } else if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 0
            menuSel = 0
        }
    } else if (currentMenu == 5) {
        if (menuSel == (itemsPerMenu[currentMenu] - 1)) {
            currentMenu = 2
            menuSel = 4
        } else if (menuSel == (itemsPerMenu[currentMenu] - 2)) {
            saveKeyBindings()
            currentMenu = 2
            menuSel = 4
        } else {
            inspectKeyboardCodes = true
            inspectKeyboardIndex = menuSel
            inspectKeyboardIdentifier = keybindingsMenuIdentifier[menuSel]
        }
    }
    
    menuOptionsNumber = itemsPerMenu[currentMenu]
}

function str2ab(str) {
  var buf = new ArrayBuffer(str.length);
  var bufView = new Uint8Array(buf);
  for (var i=0, strLen=str.length; i<strLen; i++) {
    bufView[i] = str.charCodeAt(i) & 0xFF;
  }
  return buf;
}

function loadXpSprite(name, callback) {
    var xhr = new XMLHttpRequest()
    var port = (window.location.hostname.indexOf("ganymedegate") < 0)?":8080":""
    xhr.open('GET', "http://" + (window.location.hostname || "127.0.0.1") + port + "/static/" + name + ".xp", true)
    xhr.responseType = 'arraybuffer'
     
    xhr.onload = function(e) {
        // response is unsigned 8 bit integer
        if (this.status == 200) {
            var data = data = pako.inflate(new Uint8Array(this.response))
            data.alreadyDecompressed = true
            var sp = new rexSprite.RexSprite(data)

            callback(sp)
        }
    }
     
    xhr.send()
}

function loadGenXpSprite(name, callback, noretry) {
	setTimeout(function() {
        var port = (window.location.hostname.indexOf("ganymedegate") < 0)?":8080":""
		$.ajax("http://" + (window.location.hostname || "127.0.0.1") + port + "/generated/" + name + ".xp", {
			success: function(data) {
				data = pako.inflate(atob(data))
				data.alreadyDecompressed = true
				var sp = new rexSprite.RexSprite(data)
				
				callback(sp)
			},
			error: function(xhr) {
                if (!noretry) {
                    noretry = 0
                }
                
				if (noretry < 5) {
					if (xhr.statusCode().status == 404) {
						setTimeout(function() {
                            console.log("Trying again to load: " + name)
							loadGenXpSprite(name, callback, noretry + 1)
						}, 1000)
					}
				}
			}
		})
	}, 500)
}

function keyIdentifierToText(keyId) {
    if (keyId.startsWith("U+")) {
        var code = parseInt(keyId.slice(2), 16)
        if (code == 32) {
            keyId = "Space"
        } else if (code == 127) {
            keyId = "Delete"
        } else if (code == 144) {
            keyId = "NumLock"
        } else {
            keyId = String.fromCharCode(code)
        }
    }
    
    return keyId
}

/*
    "Up": fnCommands.up,
    "Down": fnCommands.down,
    "Left": fnCommands.left,
    "Right": fnCommands.right,
    "Home": fnCommands.upleft,
    "PageUp": fnCommands.upright,
    "PageDown": fnCommands.downright,
    "End": fnCommands.downleft,
    "Clear": fnCommands.wait,
    " ": use,
    "g": grab,
    "f": fire,
    "t": superPower,
    "r": reload,
	"p": fnCommands.prone,
	"o": fnCommands.crouch,
    "i": toggleInventory,
    "v": fnCommands.toggleKeyboardLook,

keybindingsMenuIdentifier = ["Left", "Right", "Up", "Down", "UpLeft", "DownLeft", "UpRight", 
            "DownRight", "Wait", "Inventory", "Fire", "Reload", "View", "Grab", "SuperPow", "Activate", ]
*/
var positionalKeyBindingHandler = [
    fnCommands.left,
    fnCommands.right,
    fnCommands.up,
    fnCommands.down,
    fnCommands.upleft,
    fnCommands.downleft,
    fnCommands.upright,
    fnCommands.downright,
    fnCommands.wait,
    toggleInventory,
    fire,
    reload,
    fnCommands.toggleKeyboardLook,
    grab,
    superPower,
    use,
    prone,
    crouch
    ]
    
var inspectKeyboardCodes = false
$(document).ready(function () {
    $(document).keyup(function (event) {
        if (!editMode) {
            event = window.event || event
            var k = event.keyIdentifier || event.key
            var keyId = keyIdentifierToText(event.keyIdentifier || event.originalEvent.keyIdentifier)
            
            if (inspectKeyboardCodes) {
                console.log(k)
                
                keyBindingNames[inspectKeyboardIndex] = keyId
                inspectKeyboardCodes = false
                inspectKeyboardIndex = -1
                inspectKeyboardIdentifier = ""
                
                event.preventDefault()
                lastClick[0] = -1
                lastClick[1] = -1
                return
            }
            
            var alreadyHandled = false
            var res
            if (gameStarted) {
                for (var i=0; i < keyBindingNames.length; i++) {
                    if (keyBindingNames[i] == keyId) {
                        alreadyHandled = true
                        res = positionalKeyBindingHandler[i](event.shiftKey)
                        event.preventDefault()
                        break
                    }
                }
            }
            
            if (!alreadyHandled && (k in kb_hnd)) {
                res = kb_hnd[k](event.shiftKey)
                
                event.preventDefault()
            }
            
            if (res != "cursor") {
                lastMove[0] = -1
                lastMove[1] = -1
                
                lastClick[0] = -1
                lastClick[1] = -1
            }
        } else {
            event = window.event || event
            
            if ((event.keyCode == 8)||
                (event.keyCode == 37)||
                (event.keyCode == 39)) {
                editCallback(event.keyCode)
                event.preventDefault()
            }
        }
    })
    
    $(document).keydown(function (event) {
        if (!editMode) {
            event = window.event || event
            var k = event.keyIdentifier || event.key
            if (k in kb_hnd) {
                preventNextKeypress == true
                event.preventDefault()
            }
        } else {
            event = window.event || event
            
            if ((event.keyCode == 8)||
                (event.keyCode == 37)||
                (event.keyCode == 39)) {
                event.preventDefault()
            }
        }
    })
    
    $(document).keypress(function (event) {
        if (!editMode) {//(gameStarted && gameInputEnabled) {
            event = window.event || event
            var k = event.keyIdentifier || event.key
            
            if (preventNextKeypress || (k in kb_hnd)) {
                preventNextKeypress = false
                event.preventDefault()
            }
        } else {
            event = window.event || event
            editCallback(event.charCode)
            event.preventDefault()
        }
        
        if ((event.keyCode == 44)) {
            $("#shaders-edit").toggle()
        }
    })
    
    $("#fs-edit").val(ASCIITerminal.util.fragmentShaders["default"])
    $("#vs-edit").val(ASCIITerminal.util.vertexShaders["default"])
    
    if (localStorage.inited == "true") {
        pickClass(localStorage.chartype)
        tutorialSeen = localStorage.tutorialSeen == "true"
    } else {
        localStorage.inited = true
        localStorage.dupConSz = false
        localStorage.use2xsai = false
        localStorage.useMusic = true
        localStorage.useSound = true
        localStorage.tutorialSeen = false
        
        pickClass("marine")
    }
    
    loadXpSprite("title", function(sp) { titleSprite = sp })
    loadXpSprite("ganymede", function(sp) { ganymedeSprite = sp })
    loadXpSprite("gplus", function(sp) { gplusSprite = sp })
    loadXpSprite("twitter", function(sp) { twitterSprite = sp })
    loadXpSprite("reddit", function(sp) { redditSprite = sp })
    //loadXpSprite("lighthouse", function(sp) { lighthouseSprite = sp })
    
    initAsciiDisplay('term', displaySizeX, displaySizeY)
    
    createjs.Sound.registerSound("./sounds/9mmpistol.wav", "9mmpistol")
    createjs.Sound.registerSound("./sounds/rpg.wav", "rpg")
    createjs.Sound.registerSound("./sounds/shotgun.wav", "shotgun")
    createjs.Sound.registerSound("./sounds/pickup.wav", "pickup")
    createjs.Sound.registerSound("./sounds/empty_gun.wav", "empty_gun")
    createjs.Sound.registerSound("./sounds/dirt_step.wav", "dirt_step")
    createjs.Sound.registerSound("./sounds/water_step.wav", "water_step")
    createjs.Sound.registerSound("./sounds/acid_step.wav", "acid_step")
    createjs.Sound.registerSound("./sounds/lava_step.wav", "lava_step")
    createjs.Sound.registerSound("./sounds/plasma_step.wav", "plasma_step")
    createjs.Sound.registerSound("./sounds/metal_step.wav", "metal_step")
    createjs.Sound.registerSound("./sounds/reload.wav", "reload")
    createjs.Sound.registerSound("./sounds/hit.wav", "hit")
    createjs.Sound.registerSound("./sounds/gibs.wav", "gibs")
    createjs.Sound.registerSound("./sounds/open_door.wav", "open_door")
    createjs.Sound.registerSound("./sounds/switch.wav", "switch")
    
    // Laser sounds
    createjs.Sound.registerSound("./sounds/laserPistol.wav", "laserPistol")
    createjs.Sound.registerSound("./sounds/laserRifle.wav", "laserRifle")
    createjs.Sound.registerSound("./sounds/laserHeavy.wav", "laserHeavy")
    createjs.Sound.registerSound("./sounds/laserGatling.wav", "laserGatling")
    
    // Plasma sounds
    createjs.Sound.registerSound("./sounds/plasmaPistol.wav", "plasmaPistol")
    createjs.Sound.registerSound("./sounds/plasmaRifle.wav", "plasmaRifle")
    createjs.Sound.registerSound("./sounds/plasmaLauncher.wav", "plasmaLauncher")
    createjs.Sound.registerSound("./sounds/plasmaGatling.wav", "plasmaGatling")
    
    createjs.Sound.registerSound("./sounds/sniperRifle.wav", "sniperRifle")
    
    createjs.Sound.registerSound("./sounds/sword.wav", "sword")
    createjs.Sound.registerSound("./sounds/hammer.wav", "hammer")
    
    createjs.Sound.registerSound("./sounds/radio001.wav", "radio001")
    createjs.Sound.registerSound("./sounds/radio002.wav", "radio002")
    createjs.Sound.registerSound("./sounds/radio003.wav", "radio003")
    createjs.Sound.registerSound("./sounds/radio004.wav", "radio004")
    
    createjs.Sound.on("fileload", function() {
        setupMusic()
    })
    createjs.Sound.registerSound("./sounds/seedybg.wav", "seedybg")
    
    loadKeyBindings()
    
    if (typeof(require) !== "undefined") {
        if (localStorage.dupConSz) {
            window.resizeTo(1600, 1060)
        }
    }
    
    if (window.location.hostname.toLowerCase().indexOf("ganymedegate.com") >= 0) {
        showOrigin()
    }
})

function showOrigin() {
    window.twttr=(function(d,s,id){var t,js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id)){return}js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);return window.twttr||(t={_e:[],ready:function(f){t._e.push(f)}})}(document,"script","twitter-wjs"));
    $(".onlyorigin").show()
}

function goFullScreen() {
    if (
        document.fullscreenEnabled || 
        document.webkitFullscreenEnabled || 
        document.mozFullScreenEnabled ||
        document.msFullscreenEnabled
        ) {
        var i = document.getElementById("term");
         
        // go full-screen
        if (i.requestFullscreen) {
            i.requestFullscreen();
        } else if (i.webkitRequestFullscreen) {
            i.webkitRequestFullscreen();
        } else if (i.mozRequestFullScreen) {
            i.mozRequestFullScreen();
        } else if (i.msRequestFullscreen) {
            i.msRequestFullscreen();
        }
    }
}
</script>
</body>
</html>